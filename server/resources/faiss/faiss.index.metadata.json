[
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "## Introduction",
    "content": "A Brand Store provides snaps (via [channels][channels]) to systems that are configured to use the store and that are authenticated by the store. There are several parts of this system. This guide explains conceptually what these parts are and how they fit together.\n\nLet’s start by taking a look at Ubuntu Single Sign On (SSO) accounts."
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "## Ubuntu SSO accounts",
    "content": "An Ubuntu SSO account grants a logged in user a set of privileges. For\n example, a Brand Store is administered by an SSO account. Developers upload\nsnaps to a Brand Store under an SSO account. Ubuntu [assertions][assertions] are signed by\nkeys associated with an SSO account. SSO accounts also authenticate users to\n launchpad.net, forum.snapcraft.io, and additional sites and services.\n\nYou can create an SSO account here: https://login.ubuntu.com/\n\nYou can then see additional account data here:\n[https://dashboard.snapcraft.io/dev/account/][https://dashboard.snapcraft.io/dev/account/] \n\nNote the snap account-id. This is a critical identifier that is used in many\nparts of the Brand Store ecosystem. It is often referred to simply as the\naccount-id."
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "### Brand SSO account",
    "content": "The first step in creating a Brand Store is creating a dedicated Brand SSO \naccount. When requesting the Brand Store, you provide the Brand Store SSO\naccount to Canonical in order to make that account the Brand\nStore administrator. (You can add other administrators later).\n\n!!! Note:\n          It is strongly recommended to dedicate the Brand Store SSO account to\n          a single purpose of Brand activities. It should not be used for any\n          other purposes. It should be considered a critical project asset and its \n          use be strictly limited and controlled. (You can always create\n          SSO accounts for these other purposes, although each SSO\n          account requires a unique email address.)\n\nThere are several activities that must be done under the authority of this\nBrand SSO account, including:\n\n- Brand Store administration\n- Generating keys used to sign assertions, such as the model and serial\nassertions\n- Gadget snap publishing (if you are using a non-Canonical gadget snap)\n- Kernel snap publishing (if you are using a non-Canonical kernel snap)\n\nThese activities are central to managing your Brand Store, your images, and\nyour devices and are therefore considered brand activities.\n\nThe Brand Store and its Brand Store SSO account:\n\n![image][brand-store-1]"
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "### Brand SSO Keys",
    "content": "Keys created by the Brand Store SSO account are normally used to sign the\nmodel assertion included in every image that is configured to point at a Brand\n Store. You also need to generate a special serial key that is uploaded to the Serial \nVault, which provides each device a signed serial assertion that is used to \nauthenticate the device to the Brand Store.\n\n[Snapcraft][snapcraft] (the tool used to build snap packages), uses SSO \naccounts too. For example, you use `snapcraft login` to connect your terminal\n session to an SSO account. Then you can generate (`snapcraft create-key NAME`)\nand register (`snapcraft register-key NAME`) keys under that account. \n\n!!! Note:\n          It is technically possible to use different SSO accounts to\n          administer your Brand Store and manage model specific activities such\n          as signing the model and uploading the model’s custom gadget snap.\n          Using a single Brand SSO account simplifies things and is therefore\n          recommended in many situations.\n\nYou use a Brand SSO account to create keys used for brand activities:\n\n![image][brand-store-2]"
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "## Assertions",
    "content": "[Assertions][assertions] are signed pieces of information. That is, an\nassertion provides data, and the entire statement is signed by a key bound to\nan Ubuntu SSO account. This allows the source of the information to be\nauthenticated and the information it contains to be validated.\n\nThe snap system uses assertions in many places. For example, the model \nassertion (discussed next) provides key information defining the device **model**. \nIt is signed by a key under a Brand SSO account. This means it can be\n authenticated and the data it contains can be relied on as being correct."
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "## Models",
    "content": "Every system that is connected to a Brand Store contains a signed **model \nassertion**.\n\n!!! Note:\n          Any system that does not have a customized model assertion cannot use\n          a Brand Store. (Classic systems with no custom model assertion now\n          have a generic one that points at the Ubuntu Store.)\n\nThe model assertion contains data such as:\n\n- The Brand Store it points to\n- The model name\n- The Brand Store SSO account-id\n- The gadget snap name (and on Core systems, the kernel snap)\n- And more\n\nAs noted, the model assertion is **signed** by a key generated under the Brand\n Store SSO account and is placed in an image. The image is then ready to go to\nproduction and distribution. (When you create an image using the `ubuntu-image` \ntool, the model assertion and various other required assertions are inserted\n into the image automatically. If you manually create an image, you need to \ntake these steps yourself. See [Seeding a Classic\n Image][seeding-a-classic-image].)\n\n!!! Note:\n          As mentioned above, it is strongly recommended to use the Brand Store\n          SSO account to generate the key that signs the model assertion. This\n          document assumes you use the Brand Store SSO account for all such\n          purposes.\n\nUsing a Brand SSO account key to sign a model used in an image:\n\n![image][brand-store-3]"
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "## Systems pointing at the Brand Store",
    "content": "Here we overview what has been discussed so far:\n\n- Systems contain a model assertion.\n- The model assertion contains the account-id of the Brand SSO account and\nwas signed by a key made under that account.\n- The model assertion points at the Brand Store.\n\n!!! Note:\n          This picture still does not show the required system authentication\n          through which a system may gain access to its Brand Store.\n\nIts model points at a Brand Store are rejected unless authentication\n via a Serial Vault is also used:\n\n![image][brand-store-4]\n\n- Models point systems to their Brand Store\n- Systems can be rejected by the Brand Store as being unauthenticated"
  },
  {
    "filepath": "\\brand-store.md",
    "metadata": {
      "title": "Secure Brand Store Introduction",
      "table_of_contents": true
    },
    "heading": "## Authentication through the Serial Vault",
    "content": "A normally configured Brand Store authenticates a system trying to access it. \nAuthentication is done based on an authentication token called a **macaroon** (see \nfigure below). The macaroon is provided by the Canonical **Authentication\n Service**, included in the Store API, after the device has obtained a signed serial assertion. Without a \nproper serial assertion, the device cannot obtain the macaroon and is rejected \nby the Brand Store. A proper signed serial assertion is given to a system by \nthe **Serial Vault**. Obtaining a signed serial assertion from the Serial vault \nnormally occurs when the system first boots up.\n\nThis process involves a couple of pieces:\n\n- The Serial Vault needs to be configured to support the  model. This setup\nincludes the snap account-id of the Brand SSO account, a model name (which\n must be used in the model assertion mentioned previously), and a key generated\nby the Brand SSO account. Setting up the Serial Vault configuration currently \nrequires communicating with Canonical.\n- The system needs a gadget snap that has a prepare-device hook script that\n points the device to the Serial Vault. This hook script sets a few snapd\n variables: One has the URL for the Serial Vault, another defines the device’s \nserial number.\n\nOn first boot (or soon thereafter), a system obtains a signed serial assertion from its Serial Vault, uses it to obtain the macaroon from the Authentication Service, is authenticated by the Brand Store its model points to, and then uses the Brand Store’s channels to find and install snaps: \n\n![image][brand-store-5]\n\n- Gadget points at Serial Vault\n- Model points at Brand Store\n- Brand Store authenticates system by macaroon\n- Snaps are then installed over channels\n\n<!-- LINKS -->\n\n[seeding-a-classic-image]: seeding-classic-image\n[assertions]: assertions\n[snapcraft]: https://snapcraft.io\n[channels]: https://docs.snapcraft.io/reference/channels\n[https://dashboard.snapcraft.io/dev/account/]: https://dashboard.snapcraft.io/dev/account/\n\n<!-- IMAGES -->\n\n[brand-store-1]: ../media/brand-store-1.png\n[brand-store-2]: ../media/brand-store-2.png\n[brand-store-3]: ../media/brand-store-3.png\n[brand-store-4]: ../media/brand-store-4.png\n[brand-store-5]: ../media/brand-store-5.png"
  },
  {
    "filepath": "\\coresnaps.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "# Snaps in Ubuntu Core",
    "content": "Ubuntu Core is built from _snaps_, a secure, confined, dependency-free,\ncross-platform Linux packaging format.\n\nSnaps are entirely self-contained, even to the point of encapsulating their own\nfile system, and this means they include everything needed to run. They're used\nby Ubuntu Core to both compose the image that's run on a device, and to deliver\nconsistent and reliable software updates, often to low-powered, inaccessible,\nand remotely administered embedded and IoT systems.\n\nWhether it's an update to a single device, a specific subset of devices, or a\ndeployment of tens of thousands of devices, snaps enable Ubuntu Core to\nmaintain and verify a system’s integrity:\n\n- **Autonomous updates to any device** - the update service needs to be a\n  reliable and automatic process, catering for a predictable update cadence and\nan optional fine level of control over when and how updates are delivered\n\n- **Incomplete and problematic update recovery** - the inaccessible nature of\n  many embedded device installations makes it imperative that updates are\nimpregnable and capable of withstanding broken, blocked, partial and\ninterrupted updates\n\n- **Critical update provision** - in specific circumstances when an ad-hoc or\n  critical update needs to be made, the update system needs to give these\npriority and incorporate the update back into the regular update service\n\n- **Unpredictable hardware and network conditions** - in situations that can’t\n  be easily modelled or predicted, any update system needs to have enough\nredundancy to handle roll-backs, network-free bootstrapping and autonomous\nre-provisioning\n\n<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\">\n<span class=\"p-notification__status\">Note:</span>\nFor further details on how snaps work and how they're built, see \n<a href=https://snapcraft.io/docs>Snap documentation</a>.\n</p></div>"
  },
  {
    "filepath": "\\coresnaps.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Types of snap",
    "content": "The snap packaging ecosystem consists of the following parts:  \n\n- **snap** is both the command line interface and the application package format\n- **snapd** is the background service that manages and maintains your snaps\n- **snapcraft** is the command and the framework used to build your own snaps\n- **Snap Store** provides a place to upload your snaps, and for users to browse and install\n\nDevelopers can publish snaps to the Snap Store or to their own private _Brand\nStore_. They take sole responsibility for update cadence and quality. While\nsnaps are commonly known as an application packaging format, Ubuntu Core is\nbuilt from several different types of snap:\n\n1. **kernel**: defines the Linux kernel for a device  \n    The kernel snap is selected with a _model assertion_ which is produced and\nsigned before the image is built. Once the image is built, the kernel snap may\nbe updated but cannot be replaced by a completely different kernel snap.\n\n1. **gadget**: defines system properties  \n     The gadget snap is responsible for defining and manipulating the system\nproperties which are specific to one or more devices that will usually look\nsimilar to one another from an implementation perspective. \n\n1. **core**: provides the execution environment  \n     The core snap is the execution environment inside which application snaps\nrun. It also serves as the root file system for Ubuntu Core images. The current\ncore snap is built from Ubuntu 18.04 packages.\n\n1. **app**: applications, daemons and tools  \n     Packages applications, pulled from multiple upstream sources using diverse\nbuild systems. The _snapd_ daemon is itself installed as a snap (except with an\nold _core_, where it's included). \n\nAs with the core file system, snaps are presented to the system as read-only and\nare granted access to whatever resources they need through a set of explicit\npermissions, known as interfaces. Interfaces are implemented using well-tested\nLinux kernel confinement features."
  },
  {
    "filepath": "\\index.md",
    "metadata": {
      "title": "Ubuntu Core documentation",
      "table_of_contents": true
    },
    "heading": "# Ubuntu Core documentation",
    "content": "Welcome to the home of Ubuntu Core documentation.\n\n> Ubuntu Core is Ubuntu, engineered for IoT and embedded systems. It's easy to\ndeploy, tamper-resistant and hardened against corruption.\n\nUbuntu Core features:\n\n- **simple, consistent installation and deployment**: Ubuntu Core is installed\n  via an immutable image, which can be either installed or built specifically\n  for your platform and application\n- **a read-only filesystem**: apps run in isolation from each other and access\n  to system resources is only granted with explicit permissions\n- **transactional updates**: signed, autonomous and atomic, updates can withstand\n  unpredictable hardware and network conditions, even to the operating system\n- **snap-based, security first**: snaps are secure, easy to build, and painless\n  to distribute. Public/private key validation ensures what's running is\nexactly what's intended to run\n\nFrom a single Raspberry Pi, to a deployment of tens of thousands, it's the\nideal platform for anything that needs to run securely, be ever-ready,\nautonomously updated, and tamper-proof.\n\nTo learn more, take a look at the highlighted documentation below, or dive into\nthe documentation on the left.\n\n</br>\n\n| **Discovering Ubuntu Core**  |  |\n|--|--|\n| [Getting started](guides/intro/get-started.md) | Install and try Ubuntu Core on your own devices |\n| [What is Ubuntu Core](guides/intro/what-is-core.md)  | Inside Ubuntu Core's strengths and advantages |\n| [Using Ubuntu Core](using-core.md) | Access your device, install apps and manage services |\n\n| **Advanced features** |  |\n|--|--|\n| [Snaps in Ubuntu Core](coresnaps) | Discover which snaps Ubuntu Core is built upon |\n| [Security and sandboxing](guides/intro/security.md) | Security policies and how they're implemented |\n| [Core configuration](reference/core-configuration) | System options to customise your core environment |\n\n| **Building images**  |  |\n|--|--|\n| [Image building](image/image-building) | How to build images for your hardware |\n| [Custom images](image/custom-images) | Bespoke images for any supported platform |\n| [Gadget snap](reference/gadget) | Understanding the gadget snap and system properties |"
  },
  {
    "filepath": "\\platforms.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "# Supported platforms",
    "content": "Ubuntu Core runs on a large range of hardware, and pre-built images are available\nfor specific reference platforms. These images are a great way to quickly get\nstarted with Ubuntu Core on a Raspberry Pi, for example, or to explore Ubuntu\nCore's features and evaluate its potential.\n\nCanonical produces official images for the following platforms:\n\n| Platform / model name    | Hardware / CPU | Cores / memory / storage   | Image links |\n|--------------------------|--------------|-------------------|-----------|\n| Raspberry Pi         <br /> `ubuntu-core-18-pi` | Broadcom BCM2835 <br />ARM Cortex-A72 | 4/1 cores &#124; 1/2/4 GB RAM <br /> no built-in storage | [core-18-pi-arm64][18-pi-arm64] <br /> [core-18-pi-armhf][18-pi-armhf] |\n| Raspberry Pi 2       <br /> `ubuntu-core-18-pi2` | Broadcom BCM2836 <br />ARM Cortex-A7 | 4 cores &#124; 1 GB RAM <br /> no built-in storage | <br /> [core-18-pi2-armhf][18-pi2-armhf] |\n| Raspberry Pi 3       <br /> `ubuntu-core-18-pi3` | Broadcom BCM2837 <br />ARM Cortex-A53 64-bit | 4 cores &#124; 1 GB RAM <br /> no built-in storage| [core-18-pi3-arm64][18-pi3-arm64] <br /> [core-18-pi3-armhf][18-pi3-armhf]|\n| Raspberry Pi CM 3    <br /> `ubuntu-core-18-cm3` | Broadcom BCM2837 <br />ARM Cortex-A53 64-bit | 4 cores &#124; 1 GB RAM <br /> no built-in storage | [core-18-cm3-arm64][18-cm3-arm64] |\n| Raspberry Pi 4       <br /> `ubuntu-core-18-pi` | Broadcom BCM2711 <br />Cortex-A72 (ARM v8) 64-bit | 4 cores &#124; 1/2/4 GB RAM  <br /> no built-in storage | [core-18-pi4-arm64][18-pi4-arm64] <br /> [core-18-pi4-armhf][18-pi4-armhf]|\n| Qualcomm DragonBoard <br /> `ubuntu-core-18-dragonboard` | Snapdragon 410c <br /> ARM Cortex A53 64-bit | 4 cores &#124; 1 GB RAM <br /> 8 GB eMMC flash storage | [core-18-dragon][18-dragon] |\n| Intel NUC            <br /> `ubuntu-core-18-amd64` | Intel Core i3, i5, i7 64-bit | >8 cores &#124; >32 GB RAM <br /> no built-in storage | <br /> [core-18-amd64][18-amd64] |\n| Generic x86 / KVM     <br /> `ubuntu-core-18` | Full x86 32/64 bit <br /> CPU virtualisation | as defined | [core-18-amd64][18-amd64] <br /> [core18-i386][18-i386] |\n\nImages are available from\n[http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/](http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/)\n\nUbuntu Core 20 (UC20), built on the foundation of [Ubuntu 20.04 LTS (Focal\nFossa)](https://releases.ubuntu.com/20.04/), is currently under active\ndevelopment. See [Ubuntu Core 20](releases/uc20.md) for more details.\n\nUbuntu community members also work with, and produce, images for other\nplatforms and CPUs. Refer to these individual projects for more information on\nwhat other unofficial images might work for your use cases."
  },
  {
    "filepath": "\\platforms.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Installation guides",
    "content": "| Platform   | Requirements | Install guide |\n|--------------------------|--------------|-------------------|-----------|\n| Raspberry Pi 2, 3, 4 or CM3   | >2GB microSD card, display, USB keyboard, network access | <https://ubuntu.com/download/raspberry-pi-core> |\n| Intel NUC | >2GB USB flash storage, USB keyboard, display, network access | <https://ubuntu.com/download/raspberry-pi-core> | \n| Intel® IEI TANK 870 | >2GB USB flash storage, USB keyboard, display, network access | <https://ubuntu.com/download/intel-iei-tank-870> |\n| Qualcomm DragonBoard 410c | >2GB microSD card, display, USB keyboard, network access | <https://ubuntu.com/download/qualcomm-dragonboard-410c> |\n| KVM | x86 virtualisation with 10GB storage | <https://ubuntu.com/download/kvm> |\n\n\n<!-- LINKS -->\n\n[18-pi-arm64]:  http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-arm64+raspi.img.xz \n[18-pi-armhf]:  http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-armhf+raspi.img.xz \n[18-pi2-armhf]: http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-armhf+raspi2.img.xz  \n[18-pi3-arm64]: http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-arm64+raspi3.img.xz\n[18-pi3-armhf]: http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-armhf+raspi3.img.xz\n[18-cm3-arm64]: http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-armhf+cm3.img.xz\n[18-pi4-arm64]: http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-arm64+raspi4.img.xz\n[18-pi4-armhf]: http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-armhf+raspi4.img.xz  \n[18-dragon]:    http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-arm64+snapdragon.img.xz\n[18-nuc]:       http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-amd64.img.xz  \n[18-amd64]:     http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-amd64.img.xz\n[18-i386]:      http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-i386.img.xz"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## Introduction",
    "content": "A Classic image is seeded such that it is pre-populated with snaps and [assertions][assertions]. \nThat is, you add the snaps and the assertions to the image so that on first boot it\ncontains what your product needs. For example, a [gadget snap][gadget-snap] is\nnormally seeded to point the system at a Serial Vault. Also, one seeds snaps\nto provide the software that customises the system. This document explains\nwhat you may want to seed and how to do it.\n\n\n!!! Note:\n           Core images are seeded automatically with snaps and the model\n          assertion when created with the normal `ubuntu-image` tool (available\n          as a snap in the beta channel). However, `ubuntu-image` does not yet\n          support building Classic images. The principles explained\n          here can be used to manually modify a Core image after it is built\nto\n          seed additional snaps and assertions."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## What to seed",
    "content": "Usually one needs to seed:\n\n - A [model assertion][model-assertion].\n - An [account assertion][account-assertion]: for the brand SSO account used to authenticate the\nmodel assertion.\n - An [account-key assertion][account-key-assertion]: to authenticate the key that signs the model\nassertion.\n - A [gadget snap][gadget-snap] and its assertions.\n\n!!! Note:\n          The gadget snap must be uploaded using the Brand SSO account.\n\n - A core snap and its assertions.\n - Any additional snaps (each with an assertion file).\n\nHow to obtain these assertions and snap files is explained below."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## Seed directory",
    "content": "After you have built an image, you will need to add a seed directory to it\n(explained below): `/var/snapd/seed/`\n\nThis directory has a certain structure. For example:\n\n - `/var/snapd/seed/snaps/` contains the snap package files you want to seed.\n - `/var/snapd/seed/assertions/` contains the assertions you want to seed.\n - `/var/snapd/seed/seed.yaml` provides configuration data.\n\nAll you need to do is add this directory to the root of your image.\nOn first boot, snapd handles the rest, verifying the snaps by their assertions\nand installing them, and verifying and importing any assertions (such as  the\nmodel assertion)."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### Creating your seed directory",
    "content": "Create your seed directory as follows:\n\n1. Make the root seed directory:\n\n        mkdir seed\n\n1.  Make the assertions subdirectory\n\n        mkdir seed/assertions\n\n1.  Make the snaps subdirectory\n\n        mkdir seed/snaps\n\nThe seed directory needs to be owned by root user. Change ownership of these\ndirectories as follows:\n\n1. From the parent directory of `seed/`, recursively change the ownership of all files in the seed directory to the root user as follows:\n\n        sudo chown -R root:root seed\n\n\n!!! Note:\n          All files in the `seed` directory should be owned by root. Therefore,\n          this command is executed later as well."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## Getting the snap files and assertions",
    "content": "You need to add a snap file for the core snap, for the gadget snap, and for\nany other snaps you seed into the `seed/snaps/` directory. You also need to\nplace an assertion file for each snap in `seed/assertions/`.\n\n\n!!! Note:\n          You should only seed snaps that are available in the store the image\n          points at. Otherwise the snap cannot be updated in the running\n          system. (The core snap is always available in every store.)\n\nYou can download both the snap and its assertion file with a single command.\nWhen the snap is published in a Brand Store, you need to know the store ID.\nThe default behaviour downloads from the stable channel of the store. You can\noptionally download from any channel. You can also download a snap (and its\nassertion) by specifying the snap’s revision (if the snap is not published on\na channel, you can only download it by revision if you are the snap uploader\nor a collaborator).\n\nDownload the latest revision from the stable channel of the global snap store as\nfollows:\n\n    snap download SNAPNAME\n\nDownload the latest revision from the stable channel of a Brand Store (where\nthe store ID is “my-brand-store”) as follows:\n\n    UBUNTU_STORE_ID=my-brand-store snap download SNAPNAME\n\nAlternatively, add a channel option as follows:\n\n    UBUNTU_STORE_ID=my-brand-store snap --beta download SNAPNAME\n\nThe result is two files, for example:\n\n- classic-gadget-1_1.assert\n- classic-gadget-1_1.snap\n\nBy default, snap download gets a snap of the same CPU architecture as the\ncurrent host system’s CPU architecture. If your classic image is a different\nCPU architecture than your host system, you can download that different architecture \nwith the `UBUNTU_STORE_ARCH` environment variable.\n\nFor example, the following downloads a snap named classic-gadget (and its\nassertion file) from my-brand-store of CPU architecture armhf (if the store\nhas it):\n\n    UBUNTU_STORE_ARCH=armhf UBUNTU_STORE_ID=my-brand-store snap download classic-gadget\n\nNext, we cover what to do with these files."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### Getting the core snap file and assertion file",
    "content": "The core snap is always in the global snap store.\n\n1. Download the core snap and its assertion file:\n\n        snap download core\n\n1. Show the downloaded files with the `ls` command, which should output:\n\n        core_3247.assert  core_3247.snap\n\n1. Copy the snap to `seed/snaps/`\n1. Copy the assertion file to `seed/assertions/`"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### Getting the gadget snap",
    "content": "Your gadget snap may be published in a Brand Store. Let’s assume the store ID\nis “my-brand-store”.\n\n1. Download your gadget snap and its assertion file from my-brand-store as\nfollows:\n\n        UBUNTU_STORE_ID=my-brand-store” snap download SNAPNAME\n\n1. Place the snap in the `seed/snaps/` directory.\n1. Place the assertion in `seed/assertions/` directory."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### Downloading any other needed snaps",
    "content": "Follow the same procedure for each additional snap you want to seed, copying\nthe snap to `seed/snaps/` and the assertion to `seed/assertions/`."
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## Creating your seed.yaml file",
    "content": "The `seed.yaml` file tells snapd which snaps are seeded in the image (and\nincluded in the seed directory).\n\n1. Create the file in `seed/seed.yaml`.\n1. For each snap, fill in the following information:\n\n        snaps:\n          - name: core\n            snap-id: THE-SNAP-ID\n            channel: stable\n            file: core_3017.snap\n          - name: gadget-gateway7\n            snap-id: THE-SNAP-ID\n            channel: stable\n            file: gadget-gateway7_1_amd64.snap\n\n\n!!! Note:\n          A snap ID is a long alphanumeric string, for example:\n          `X03kFuB2OQ3oiEI563kRMSgdQc8YiBfX`\n\nYou can get the snap ID for the core snap (or any other snap) with the `snap\ninfo SNAPNAME` command:  \n\n    snap info core | grep snap-id\n    \nWhich will return:\n    \n    snap-id:     99T7MUlRhtI3U0QFgl5mXXESAiSwt776"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### The model assertion",
    "content": "As explained elsewhere, each Brand Store generally has an associated Brand SSO\naccount that is used for critical brand activities. This includes making and\nsigning the model assertion:\n\n - The model assertion must state the account-id of the Brand SSO account in\nthe brand-id and the authority-id fields.\n - The model assertion must be signed by a key generated under the Brand SSO\naccount, and it must be registered.  \n\nAlso note:\n\n - The `store` field value must be the Brand Store ID.\n - The `model` field value must be registered in the Serial Vault.\n - The model must have `“classic”: true`\n - If the classic image has a gadget snap, it must be mentioned in the model:\n\n        “gadget”: “GADGET-NAME”\n\nSign the model assertion json file as follows:\n\n    cat model.json | snap sign -k model-key > model\n\nFor background information on model assertions and signing them, see\n[image building][image-building]"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### Getting the Brand SSO account assertion",
    "content": "As noted, the Brand SSO account is used to generate the key used to sign the\nmodel. Therefore, this account assertion needs to be seeded for the model to\nbe authenticated.\n\nYou can download this account assertion as follows:\n\n1. Login to snapcraft:\n\n        snapcraft login\n\n    And enter the Brand SSO account credentials.\n\n1. Display the SSO account’s account-id with `snapcraft whoami`:\n\n        snapcraft whoami\n        email:        THE-EMAIL\n        developer-id: THE-ACCOUNT-ID\n\n1. Download the Brand SSO account assertion:\n\n        snap known account account-id=THE-ACCOUNT-ID > brand-account.assert"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "### Getting the Brand account-key assertion",
    "content": "As noted, you need to obtain the account-key assertion for the key that signed\nthe model. For this, you need the SHA3-384 fingerprint of the key. If the keys\nwere generated on a system you can access, you can do the following on the\nsystem:\n\n1. Login to snapcraft using the Brand SSO account details on the machine on\nwhich the model signing key was generated.\n1. Display known keys and copy the SHA3-384 fingerprint of the key used to\nsign the model with `snapcraft list-keys`:\n\n        snapcraft  list-keys\n            Name         SHA3-384 fingerprint\n        *   model     KEY-SHA3-384-FINGERPRINT\n        *   serial    KEY-SHA3-384-FINGERPRINT\n\n    If the keys were generated on another system, you need someone who can access that system to provide the fingerprint.\n\n1. With the fingerprint, obtain the assertion as follows:\n\n        snap known account-key --remote public-key-sha3-384=KEY-SHA3-384-FINGERPRINT > brand-account-key.assert"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## Placing the seed directory into your image",
    "content": "Now, simply copy the seed directory and its contents into your image\nin `/var/snapd/`, resulting in: `/var/snapd/seed/`.\n\nAs noted, the seed directory and all files in it need to be owned by root\nuser. Recursively set ownership to root as follows:\n\n1. From the parent directory of seed/, change the owner recursively to root\nuser as follows:\n\n        sudo chown -R root:root seed"
  },
  {
    "filepath": "\\seeding-classic-image.md",
    "metadata": {
      "title": "Seeding a classic Ubuntu Image",
      "table_of_contents": true
    },
    "heading": "## Verifying seeding success",
    "content": "You can verify success in a running image as follows:\n\n1. Verify the snaps you seeded are installed with:\n\n        snap list\n\n    You should see each snap you seeded listed as installed.\n\n1. Verify the model assertion with:\n\n        snap known model\n\n    You should see the model assertion you seeded.\n\n1. If your gadget snap includes a prepare-device hook in order to obtain a\nsigned serial assertion from a Serial Vault, you can check the status with:\n\n        snap known serial\n\n    If there is no serial assertion, the transaction may be in progress, so use:\n\n        snap changes\n\n    Find the `Initialize device` change. If its status is not `Done`, note the ID and\ncheck the details of the change with:\n\n        snap change ID\n\n\n[image-building]: image-building\n[gadget-snap]: https://forum.snapcraft.io/t/the-gadget-snap/696\n[assertions]: assertions\n[account-assertion]: account\n[account-key-assertion]: account-key\n[model-assertion]: model"
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "# Serial Vault user guide",
    "content": "The Serial Vault is a Canonical-hosted web service which must be used\nif you want to maintain a [secure Brand Store][secure-brand-store]. \nThe Serial Vault provides:\n\n - Signed [serial assertions][serial-assertions] to authenticated systems of\n   a given brand/model, which then use it to access a secure Brand Store.\n - Signed [system-user assertions][system-user-assertions], which allow\n   creating a system user account from a USB drive on an Ubuntu Core system\n   which currently has no system user set.\n   For additional information, see [here][here].\n\nAfter Canonical creates your Serial Vault account, you can login here:\n[https://serial-vault-partners-admin.canonical.com]\n\nSerial Vault tasks include:\n\n - Generating and uploading new serial keys.\n - Creating new models and associating them with a key and your brand.\n - Reviewing serial signing logs.\n - Optionally creating system user assertions.\n\n\n!!! Note:\n          The Brand SSO account is used for all brand activities, including\n          generating the serial key, as explained here.\n\nPlease contact Canonical to request a Serial Vault user account. The account\nmust be associated with the Brand SSO account of your Brand Store. Canonical\nwill need the following:\n\n - The Username of the brand SSO account from [https://login.ubuntu.com/][https://login.ubuntu.com/] \n - The Brand SSO account ID from [https://dashboard.snapcraft.io/dev/account/][https://dashboard.snapcraft.io/dev/account/] \n - The email address of the Brand SSO account from [https://dashboard.snapcraft.io/dev/account/][https://dashboard.snapcraft.io/dev/account/] \n\n\n!['image'][serial-vault-image1]"
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Gadget snap",
    "content": "Systems requesting a serial assertion must have a [gadget snap][gadget-snap].\nThat snap includes a [prepare-device][prepare-device] hook script where\ndetails of the system and Serial Vault connection such as the URL, API key,\nand serial number are defined.\n\nThe following table explains the configuration settings that need to be in the\nprepare-device hook:\n\n| snapd setting                | Description                                                                                                                                                                                                                                                                                                                                                                                                                            |   |   |   |\n|------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---|---|---|\n| device-service.url           | The base API URl for the Serial Vault, ending in a trailing slash (\"/\"). <br> This value must be set to: `https://serial-vault-partners.canonical.com/v1`                                                                                                                                                                                                                                                |   |   |   |\n| device-service.headers       | The API key defined as an HTTP header in JSON string format.  This value must match the one configured for this device model in the SerialVault Admin portal web user interface. <br> You can generate a valid API key with `$pwgen 64 1` and then copy it into the Serial Vault when creating your Model. Or, you can auto create the API key in the Serial Vault when creating a Model and copy it into the `prepare-device` hook script. |   |   |   |\n| registration.proposed-serial | The unique serial number of the device. How to get this serial depends on the device platform.                                                                                                                                                                                                                                                                                                                                         |   |   |   |"
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "## Getting the account-id of your Brand SSO account",
    "content": "Requirements:\n\n - snapd must be installed.\n - snapcraft must be installed.\n - Must be snapcraft logged on as Brand SSO account.\n\nYou need to generate a key used by the Serial Vault to sign serial assertions\nand system-user assertions. These keys must be generated under the Brand SSO\naccount. After generating a key, you register it, encrypt it, and upload it to\nthe Serial Vault. These are all brand activities performed under the Brand SSO\naccount. \n\nThroughout the following tasks, you need to use the account-id of your Brand\nSSO account in various places. You can display this account-id as follows:\n\n1. Login to snapcraft with Brand SSO account credentials:\n\n```bash\nsnapcraft login\n```\n\nYou will be prompted for the email address and password - be sure to use the email and password of the vendor SSO account.\n\n\n1. Display the SSO account’s account-id:\n```bash\nsnapcraft whoami\n```\n\nThis should return information in the form: \n\n```\nemail:        vendor.sso@example.com\ndeveloper-id: enAn0ZFfJUhbdHt2T7AjNeCI65vPt2iY\n```\n\nThe developer-id listed here is the account-id of the Brand SSO account."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "## Providing a key",
    "content": "You need to generate a snapcraft key, register it, encrypt it, and upload it\nsecurely to the Serial Vault."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Generating a key",
    "content": "Generate the keys for signing serial and system-user assertions as follows:\n\n!!! Note:\n          Keys used for brand purposes are critically important assets that\n          should not be lost. Snapcraft keys are created in ~/.snap/gnupg/.\n          Ensure you back this directory up to a secure external medium.\n          Registering the key does not upload the key and therefore does not\n          support key recovery.\n\n```bash\nsnap create-key serial \n```\n\nYou will be prompted for a passphrase. In this case, the passphrase **MUST BE BLANK** so just press `Return` twice.\n\nNote that it takes some time to create the key. \n\nAfter completion, verify creation with the following command:\n\n```bash\nsnapcraft list-keys\n```\nThis will return a list of the known keys. At the moment, the key you just added will be marked as 'not registered'.\n\n```bash\n    Name \tSHA3-384 fingerprint\n-   serial   yOkSks8x1OICgx60WW-YEKehTeWvQpE2qA17ZM-RT8i0u7YYrIOjSp1DARkv4Cuu \n(not registered)\n```"
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Registering the key",
    "content": "Register the key to the Brand SSO account as follows:\n\n```bash\nsnapcraft register-key serial\n```\n\nYou can confirm the key has been added with the command:\n\n```bash\nsnapcraft list-keys\n```\n...which will now list the key with an asterisk (`*`) denoting that it is registered:\n\n```bash\n    Name \tSHA3-384 fingerprint\n*   serial   yOkSks8x1OICgx60WW-YEKehTeWvQpE2qA17ZM-RT8i0u7YYrIOjSp1DARkv4Cuu\n```"
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Exporting the key",
    "content": "Before uploading the key, it must be encrypted. Export the key using ASCII\narmored encryption, as follows:\n \n```bash\ngpg --homedir ~/.snap/gnupg --armor --export-secret-key serial > serial.asc\n```\n\nIn this example, serial.asc is the serial key file to upload to Serial Vault.\nYou name a key used to sign system-user assertions differently."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Uploading the key to the Serial Vault",
    "content": "1. Login to the Serial Vault as the Brand SSO account.\n1. Select Models.\n\n\n\n![image][serial-vault-image2]\n1. Click the Signing Keys + button.\n\n\n\n![image][serial-vault-image3]\n\n\n\n![image][serial-vault-image4]\n\n1. Enter account-id of the Brand SSO account as the Signing Authority.\n1. Under Signing Key, click Browse, then find and select the previously\ncreated ASCII-armored serial key file.. \n1. Click Save. \nThe list of models and signing keys displays, including this new one."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "## Creating a model",
    "content": "You need to create a model. This corresponds to the model previously used when\nbuilding an image. (Every system has a model.) At runtime, the system sends\nthe model to the Serial Vault, which uses it to authenticate the system before\ngenerating a serial assertion.\n\nThe model contains key data that must exactly match data in the model in the\ndeployed system, including:\n\n - brand-id: this is the account-id of the Brand SSO account\n - model name\n\nAlso, the system itself must have a gadget snap whose prepare-device hook\ndefines required snapd variables. See “Gadget Snap” section below for details\non these variables. \n\nCreate a model as follows:\n\n1. Click Models.\nOn first use, you have no models.\n1. Click the “+” button to the right of Models:\n\n\n![image][serial-vault-image5]\n\n\n![image][serial-vault-image6]\n\n1. Enter the account-id of your Brand SSO account into the Brand field.\n1. Enter the model name (from your system’s model assertion) into the Model\nfield.\n1. The API Key must match the setting in your gadget snap prepare-device hook\n(see Gadget Snap section above). If you leave this field empty, an API key is\ngenerated and  you must use this new value in your gadget snap prepare-device\nhook script. If your gadget snap prepare-device hook already defines the API\nkey, you must copy it from the hook into this field. \n1. Select the Serial Assertion Key corresponding to the serial key you\npreviously uploaded.\n1. In System-User Assertion Key, select a key you previously uploaded. This\ncan be the serial key, or another one.\n1. Click Save.\n\nThis model is now active. The Serial Vault responds to requests from systems\nthat match with a signed serial assertion that the system then uses to access\na secure Brand Store. \n\nThe Models page now lists your model:\n\n![image][serial-vault-image7]\n\nYou can edit an existing model by pressing a model’s pencil icon button."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "## Checking the Signing Log",
    "content": "You can review the Signing Log to check whether serial assertions have been\nsigned and issued.\n\nThe Signing Log displays the list of serial numbers and device keys that have\nbeen used to sign serial assertions. You can also filter the log. \n\n![image][serial-vault-image8]"
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "## Creating system-user assertions",
    "content": "A system-user assertion allows you to create a user on an unmanaged Core\nsystem. The system-user assertion can be pre-populated into an image, or it can be\nauto-imported from a USB drive. See here and [system user][system-user] and\n[system user assertions.][system-user-assertions.] \n\nThe system-user assertion is signed by a key you create, register, export and\nupload to the Serial Vault just like the serial key. See the the content\nelsewhere in this doc for detailed instructions.\n \nThe System-User menu lets you create system user assertion for a certain brand\n/model, as follows:\n1. Click System-User.\n1. Enter the email of the system user into Email field.\n1. Enter the desired login name of the system user in Username field.\n1. Enter the system user password in Password field.\n1. Enter complete name of the user in Full Name field.\n1. Select the model of the device this user is being created from Model combo\nbox.\n1. Set date and time in UTC since this assertion is valid in Since (UTC)\nfield.\n\n!!! Note:\n          This date must be after the date on which the key used to sign the\n          system user assertion was registered.  \n1. Press Create to generate the assertion.\n\n!['image'][serial-vault-image9]\n\nAfter pressing Create, the generated assertion is displayed. Click Download \nto save it to a local file. \n\nAs explained in linked documents, you can place this file in the root\ndirectory of a USB drive and named auto-import.assert. If the USB drive is\ninserted in an unmanaged Core system, the assertion is imported and the system\nuser is created."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "## Verifying a system obtained a serial assertion",
    "content": "You can verify from a terminal session on a system if a serial assertion has\nbeen retrieved from the Serial Vault in various ways.\n\n\n!!! Note:\n          If the Core system does not have a user so you cannot get a terminal\n          session into the device, you can create one with a system-user\n          assertion as explained [elsewhere in this document](#creating-system-user-assertions)."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Verifying serial with snap known serial",
    "content": "Display the system’s serial assertion, if any, as follows:\n\n```bash\nsnap known serial\n```\n\nThe output should show a variety of information, including the serial identifier:\n\n```bash\ntype: serial\nauthority-id: canonical\nbrand-id: mybrand\nmodel: rpi3\nserial: 381d1f99-749f-41f5-a667-608f698a4a4a\ndevice-key:\n\tAcbBTQRWhcGAARAAzFqvP/235lVcpelVL2RxxHnDwi0viTLFdk3QxrSDfmLlTrP/griNH5zfDPHH\nQf7mCC2yrjPLgSPmDvZm58Mnh3y+TFL9dF6lF6L0qXM865LO07sD1nZKE9lvl61jt+opmHviwTvb\n...\n```\n\nIf there is no output from this command, the system does not have a serial assertion\nassigned."
  },
  {
    "filepath": "\\serial-vault.md",
    "metadata": {
      "title": "Serial Vault User Guide",
      "table_of_contents": true
    },
    "heading": "### Checking `Initialize device` transaction with snap changes",
    "content": "The system reports transactions with snap changes. The Initialize device\ntransaction includes Serial Vault operations. If snap known serial does not\noutput a serial assertion, you can troubleshoot further as follows:\n\n1. Display snap changes with the command:\n\n```bash\nsnap changes\n```\n\nThis lists the transactions in reverse chronological order (most recent first), labelling each with an ID:\n\n```bash\nID   Status  Spawn                 Ready                 Summary\n1    Done    2016-12-01T10:50:30Z  2016-12-01T10:55:26Z  Initialize system\nstate\n2    Doing    2016-12-01T10:50:52Z  2016-12-01T10:54:53Z  Initialize device\n```\n\n1. Display the detail about the initialize device change with its ID, as\nfollows:\n\n```bash\nsnap change 2\n```\n\nAny status other than `Done` indicates that the transaction has not yet \nbeen able to complete successfully:\n\n```bash\nStatus  Spawn             \tReady               Summary\nDone\t2017-10-23T14:33:10Z  2017-10-23T14:50:53Z  Run prepare-device hook\nDone\t2017-10-23T14:33:10Z  2017-10-23T14:50:53Z  Generate device key\nDoing   2017-10-23T14:33:10Z  -                     Request device serial\n\n......................................................................\nRequest device serial\n\n2017-10-24T05:31:31Z ERROR cannot retrieve request-id for making a request for\na serial: Post https://serial-vault-partners.canonical.com/v1/request-id: dial tcp 10.50.182.5:443: connect: network is unreachable\n2017-11-02T13:22:43Z ERROR cannot retrieve request-id for making a request for\na serial: Post https://serial-vault-partners.canonical.com/v1/request-id:\nnet/http: request canceled while waiting for connection (Client.Timeout\nexceeded while awaiting headers)\n```\n\n<!-- LINKS -->\n\n[system-user-assertions.]: ./reference/assertions/system-user\n[system-user]: ./guides/manage-devices/index\n[prepare-device]: ./guides/build-device/gadget\n[gadget-snap]: https://forum.snapcraft.io/t/the-gadget-snap/696\n[https://dashboard.snapcraft.io/dev/account/]: https://dashboard.snapcraft.io/dev/account/\n[https://login.ubuntu.com/]: https://login.ubuntu.com/\n[here]: ./guides/manage-devices/index\n[system-user-assertions]: ./reference/assertions/system-user\n[serial-assertions]: ./reference/assertions/serial\n[secure-brand-store]: https://docs.google.com/document/d/1L6Tqu8ntpYaKGIi-Kh5W-2vrMoBKA0KhyLoaRJhbDHU\n[checking-initialize-device-transaction-with-snap-changes]: #checking-initialize-device-transaction-with-snap-changes\n[verifying-serial-with-snap-known-serial]: #verifying-serial-with-snap-known-serial\n[verifying-a-system-obtained-serial-assertion]: #verifying-a-system-obtained-serial-assertion\n[creating-system-user-assertions]: #creating-system-user-assertions\n[checking-the-signing-log]: #checking-the-signing-log\n[creating-a-model]: #creating-a-model\n[uploading-the-key-to-the-serial-vault]: #uploading-the-key-to-the-serial-vault\n[exporting-the-key]: exporting-the-key\n[registering-the-key]: #registering-the-key\n[generating-a-key]: #generating-a-key\n[providing-a-key]: #providing-a-key\n[getting-the-account-id-of-your-brand-sso-account]: #getting-the-account-id-of-your-brand-sso-account\n[gadget-snap]: #gadget-snap\n\n<!-- IMAGES -->\n\n[serial-vault-image0]: ../media/serial-vault-image0.png\n[serial-vault-image1]: ../media/serial-vault-image1.png\n[serial-vault-image2]: ../media/serial-vault-image2.png\n[serial-vault-image3]: ../media/serial-vault-image3.png\n[serial-vault-image4]: ../media/serial-vault-image4.png\n[serial-vault-image5]: ../media/serial-vault-image5.png\n[serial-vault-image6]: ../media/serial-vault-image6.png\n[serial-vault-image7]: ../media/serial-vault-image7.png\n[serial-vault-image8]: ../media/serial-vault-image8.png\n[serial-vault-image9]: ../media/serial-vault-image9.png"
  },
  {
    "filepath": "\\using-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "# Using Ubuntu Core",
    "content": "<!-- \nVersion: 2.0\n-->\n\n[Ubuntu Core](index.md) is designed for IoT and embedded environments, from a\nsingle device to a factory deployment of thousands. But it's also a great\nplatform for experimentation and project building.  \n\nFor more details on which platforms are supported, and for links to\ninstallation guides, see [Supported platforms](platforms.md)."
  },
  {
    "filepath": "\\using-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Accessing an Ubuntu Core system",
    "content": "Access to a self-deployed Ubuntu Core system is via the networking\nconfiguration and [SSH key](https://login.ubuntu.com/ssh-keys) linked to the\n[Ubuntu SSO account](https://login.ubuntu.com/) used to set up the system.\n\nIf you have a display connected to your device, it will display the account and\nIP address, alongside host key fingerprints, upon successful boot:\n\n```no-highlight\nUbuntu Core 20 on 10.0.2.15 (tty1)\nThe host key fingerprints are:\n\n    RSA     SHA256:PaSE+kKJLKSDREKJeiKLKJeJ3JKLKJEEKJ\n    ECDSA   SHA256:wIKSDFLKsdlkfsjDFSdfujsdf83kljSDdD\n    ED25519 SHA256:7JSDFSDkdsS3KJKSDsdflkfSDFLJKDSs39\n\nTo login:\n\n    ssh <sso-id>@10.0.2.15\n\nPersonalize your account at https://login.ubuntu.com.\n```\n\nBy default, you can only access your deployed Ubuntu Core system from SSH, and\nnot physically from the device itself. See [System\nuser](/guides/manage-devices/) for details on how to create a system user with\nlocal login on systems that allow _classi_confinement (notably, not Ubuntu Core\n20)."
  },
  {
    "filepath": "\\using-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## User environment",
    "content": "The Ubuntu Core user environment operates much like a traditional Ubuntu\nenvironment with the exception that you can only install and configure your\nsystem through _snap_ packages.\n\nTo see which snap packages are installed, type `snap list`:\n\n```bash\n$ snap list\nName       Version               Rev   Tracking     Publisher   Notes                                                                            \ncore20     20                    634   latest/edge  canonical✓  base                                                                             \npc         20-0.4                101   20/beta      canonical✓  gadget                                                                           \npc-kernel  5.4.0-31.35           502   20/beta      canonical✓  kernel                                                                           \nsnapd      2.45+git396.g5c3995e  7790  latest/edge  canonical✓  snapd\n```\n\nSee [Snaps in Ubuntu Core](coresnaps.md) for more details on what these snaps\ndo and how they're used.\n\nTo install a new snap package, type `snap install <snap-name>`:\n\n```bash\n$ snap install nextcloud\nnextcloud 18.0.4snap1 from Nextcloud✓ installed\n```\n\nUse the `remove` argument to remove a snap.\n\n<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\">\n<span class=\"p-notification__status\">Snap documentation:</span> to learn more about how snaps work, and how to use, see the \n<a href=\"https://snapcraft.io/docs/\">Snap documentation.</a>\n</p></div>"
  },
  {
    "filepath": "\\using-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Configuring a snap",
    "content": "You can view and set specific configuration options for a snap with the _get_\nand _set_ commands:\n\n```bash\n$ snap get nextcloud\nKey        Value\nmode       production\nnextcloud  {...}\nphp        {...}\nports      {...}\nprivate    {...}\n\n$ snap get nextcloud ports\nKey          Value\nports.http   80\nports.https  443\n\n$ sudo snap set nextcloud ports.http=81\n```\n\n<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\">\n<span class=\"p-notification__status\">Setting snap options:</span> for more details on setting snap-specific options, see\n<a href=\"https://snapcraft.io/docs/configuration-in-snaps\">Managing snap configuration.</a>\n</p></div>"
  },
  {
    "filepath": "\\using-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Managing a snap service or daemon",
    "content": "If a snap provides one or more services, they can be listed with the _services_\ncommand:\n\n```bash\nsnap services nextcloud\nService                    Startup  Current  Notes\nnextcloud.apache           enabled  active   -\nnextcloud.mdns-publisher   enabled  active   -\nnextcloud.mysql            enabled  active   -\nnextcloud.nextcloud-cron   enabled  active   -\nnextcloud.nextcloud-fixer  enabled  active   -\nnextcloud.php-fpm          enabled  active   -\nnextcloud.redis-server     enabled  active   -\nnextcloud.renew-certs      enabled  active   -\n```\n\nUse _start_ and _stop_ to control whether a service is running:\n\n```bash\n$ snap stop nextcloud.apache\nStopped.\n```\n\nTo prevent a service from starting on the next boot, use the `--disable`\noption:\n\n```bash\n$ snap stop --disable nextcloud.apache\n```\n\nThe inverse of the above is `start --enable` to start a service and enable it\nat boot time:\n\n```bash\n$ snap start --enable nextcloud.apache\n```"
  },
  {
    "filepath": "\\using-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Accessing logs",
    "content": "If you need to see the log output for a snap’s services, use the logs command:\n\n```bash\n$ snap logs nextcloud\n2020-05-14T10:50:57Z systemd[1]: Stopping Service for snap application nextcloud.apache...\n2020-05-14T10:50:57Z nextcloud.apache[49131]: No certificates are active: using HTTP only\n```\n\nAdding the -f option will keep log output open so you can follow new entries as they occur:\n\n```bash\n$ sudo snap logs nextcloud -f\n```\n\n<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\">\n<span class=\"p-notification__status\">Service management:</span> for more details on starting and stopping services, see\n<a href=\"https://snapcraft.io/docs/service-management\">Service management.</a>\n</p></div>"
  },
  {
    "filepath": "\\build-store\\develop.md",
    "metadata": {
      "title": "Develop",
      "table_of_contents": true
    },
    "heading": "# Develop",
    "content": "This page will give you an overview of the lifecycle of a snap package on a brand store, with a focus on its differences with the main snap store. These differences are minimal and if you are already familiar with snaps and snapcraft, you can jump to learning how to [upload snaps to a specifc store](upload-snaps.md)."
  },
  {
    "filepath": "\\build-store\\develop.md",
    "metadata": {
      "title": "Develop",
      "table_of_contents": true
    },
    "heading": "## Lifecycle of a snap package",
    "content": "Snap packages are built using snapcraft, a command-line tool which uses a YAML file as a declaration to build a package. You can easily get started with snapcraft on [snapcraft.io](https://snapcraft.io/docs/build-snaps/).\n\nIn a nutshell, the lifecycle of a snap is the following:\n\n1. Once you have built a snap, it can be pushed and released to any snap store allowing you to do so: from the command-line, from the store web UI, or from your continuous integration pipeline (eg. Travis).\n\n2. Snaps have their names tied and registered to a specific store, allowing for an inheritance model between stores. For example, your brand store can distribute a \"my-app\" snap inherited from the main snap store. To distribute your customized version of \"my-app\", you will have to pick a different name for it (eg. \"my-brand-app\"), allowing users to easily differentiate between the two. This also means that no other store will be able to distribute \"my-brand-app\", unless you allow it to inherit from yours.\n\n3. Snaps can be released through severals tracks (\"latest\", \"1.0\", \"2.0\", etc) you can create to match your software versioning scheme, each track allowing for four channels: stable, candidate, beta and edge, giving your users a very clear picture of what they are installing and its stability level.\n\n4. The snapd client, installed on all user devices, checks the store the client is connected to for updates several times a day and upgrades to the latest available version of your snap, for the track/channel the user is following."
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "# Store overview",
    "content": "Ubuntu Core includes access to the to Canonical's [Snap\nStore](https://snapcraft.io/store) by default. This allows any developer to\neasily release and support apps for multiple architectures, on multiple release\nchannels, from daily builds to stable releases.\n\nSee [Releasing to the Snap\nStore](https://snapcraft.io/docs/releasing-to-the-snap-store) for more details\non how to publish and distribute snaps to devices from the Snap Store."
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "## Brand stores",
    "content": "For larger projects and ISVs, it is often a requirement to publish snaps using a\nbrand account to a brand-specific store. \n\nA brand store allows vendors running Ubuntu Core and snap-based devices to\ncontrol exactly what snaps are available, and when. It can inherit selected\npackages from other snap stores, and host a set of snaps specific to a brand\nand device models, and be either open to all developers or a specific list.\n\nHere is an overview of how to create a brand account and define\ncollaborators."
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "## Registering accounts",
    "content": "To create an account, go to\n[https://snapcraft.io/account](https://snapcraft.io/account). We then recommend\nthe following process:\n\n* create an umbrella/brand account using the project name or name of the legal\n  entity publishing the software\n* let each team member who releases and manages snaps register a personal\n  account\n* grant each team member access to the snaps by adding their personal accounts\n  as collaborators"
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "## Registering Snaps",
    "content": "Snaps can be registered using the `snapcraft` tool or via the web. Snaps should\nbe registered using the brand/umbrella account."
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "### Registering snaps with Snapcraft",
    "content": "* install `snapcraft` using `snap install snapcraft --classic` on Linux or\n  `brew install snapcraft` on macOS\n* execute `snapcraft login` and authenticate using the brand/umbrella account\n* once authenticated register the snap name(s) with `snapcraft register\n  yoursnapname`\n\nFor more details on this process, see [Registering your app\nname](https://snapcraft.io/docs/registering-your-app-name)."
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "### Registering snaps via the web",
    "content": "- login to [https://snapcraft.io]() using the brand/umbrella account\n- register snap(s) here: [https://snapcraft.io/account/register-name]()"
  },
  {
    "filepath": "\\build-store\\index.md",
    "metadata": {
      "title": "App stores",
      "table_of_contents": true
    },
    "heading": "## Collaborators",
    "content": "When you've registered snap(s) using a brand/umbrella account, you should add\nteam members' personal accounts to the umbrella/brand account via the Dashboard\nfor your snap. For example:\n\nhttps://dashboard.snapcraft.io/snaps/yoursnapname/collaboration/\n\nCollaborators can then push and release snaps using their personal accounts."
  },
  {
    "filepath": "\\build-store\\issues.md",
    "metadata": {
      "title": "Report an issue",
      "table_of_contents": true
    },
    "heading": "# Report an issue",
    "content": "The open source Ubuntu Core project is very distributed, the source code of its various parts are hosted in Launchpad and GitHub, and most communications are done through IRC and on the Snapcraft mailing list."
  },
  {
    "filepath": "\\build-store\\issues.md",
    "metadata": {
      "title": "Report an issue",
      "table_of_contents": true
    },
    "heading": "## Issue trackers",
    "content": "* [Store and API](https://bugs.launchpad.net/snapstore)\n* [Reviewer tools](https://bugs.launchpad.net/click-reviewers-tools)\n* [snapd](https://bugs.launchpad.net/snapd)\n* [snapcraft](https://bugs.launchpad.net/snapcraft)\n\nIf you are not sure where your report belongs, please use the [general bug tracker](https://bugs.launchpad.net/snappy)."
  },
  {
    "filepath": "\\build-store\\issues.md",
    "metadata": {
      "title": "Report an issue",
      "table_of_contents": true
    },
    "heading": "## Get support",
    "content": "Support is jointly provided by community and main project developers.\n\n* [Chat in real time on IRC](https://webchat.freenode.net/?channels=snappy) (#snappy channel on freenode IRC)\n* [Join the snapcraft mailing list](https://lists.ubuntu.com/mailman/listinfo/snapcraft)"
  },
  {
    "filepath": "\\build-store\\manage.md",
    "metadata": {
      "title": "Manage",
      "table_of_contents": true
    },
    "heading": "# Manage",
    "content": "Brand stores have two administrative roles: admins and reviewers.\n\n* Admins manage general settings of the store, such as security policies enforced on packages and snaps it includes from other stores.<br>[What are the available settings?](settings.md)\n* Reviewers control the flow of packages to users, comment on, approve or reject uploaded snaps, grant per-snap overrides for warnings and errors detected by the automated review process and set up per-snap features, such as automated aliases, auto-connecting interfaces, and refresh control.<br>[How to review a snap?](reviews.md)"
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## What is Refresh Control?",
    "content": "Refresh Control is a mechanism for controlling the revisions of a snap that will be offered as updates  to a device. A *gating snap* can control the revisions of a *gated snap* so that, if the *gating snap* is installed on a device, only revisions of the *gated snap* which have been validated by the publisher of the *gating snap* can be installed or refreshed to.\n\nA gating snap can control revisions of one or more gated snaps. Similarly, a gated snap can require verification from more than one gating snap, and a particular revision of the gated snap will only be installable or refreshable to, if it satisfies the constraints of all its gating snaps. However, because it can be confusing to device operators, use of multiple gating snaps to control one specific gated snap is not recommended. The best practice is to use a single gating snap for each gated snap.\n\nThis is especially useful for device manufacturers to mediate releases of the *core* snap, allowing time for testing and validation of new revisions on their device models and compatibility with their software.  Note this is separate from the ability for device managers to control the schedule of refreshes and revision control via a snap proxy."
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## Preliminary setup",
    "content": "Establishing the relationship between a gating and gated snap is required only once and can only be performed by a user with reviewer permission for the gating snap's store.\n\nAsk a store reviewer to edit the package declaration for the gating snap on the [snap's page][1]. The reviewer should:\n\n* Click on \"review capabilities\"\n* Under \"Refresh Control\" put a json list with the snap IDs of one or more snaps you want gated: \\[\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", ...\\]. Keep in mind this gating snap will be able to control updates for all the gated snaps."
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## Gating snap publisher's signing key setup",
    "content": "Since gating involves pushing [`validation` assertions][2] which are signed by the publisher indicating their authorization to restrict updates of snaps, some GPG keys must be generated and published to the store. If a store key already exists, it can be used. If not, one must be generated and registered.\n\n1. `snapcraft create-key` to create a key. (by default it's named \"default\" but a key name can be given to create a custom one so e.g. each snap is signed with its own key). Do not forget the passphrase used to secure the key or misplace the key files.\n\n    ```\n    $ snapcraft create-key my-key\n    Passphrase:\n    Confirm passphrase:\n    $ snapcraft list-keys\n        Name          SHA3-384 fingerprint\n    -   my-key       mfomTtPB1cE3IFs51NtdnFoPlQwJxFgxOMU_q0mPkH7M2gKB-4m28d99XrVjA53B  (not registered)\n    ```\n\n2. `snapcraft register-key <the-key-name>` to register it with the assertion server.\n\n    ```\n    $ snapcraft register-key my-key\n    Enter your Ubuntu One e-mail address and password.\n    If you do not have an Ubuntu One account, you can create one at https://dashboard.snapcraft.io/openid/login\n    Email: roadmr.developer@example.com\n    Password:\n    Second-factor auth: 111111\n    Registering key ...\n    Done. The key \"my-key\" (mfomTtPB1cE3IFs51NtdnFoPlQwJxFgxOMU_q0mPkH7M2gKB-4m28d99XrVjA53B) may be used to sign your assertions.\n    ```"
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## Example gating workflows (part 1)",
    "content": "At this point, the publisher can issue validations asserting which revision of the gated snap is allowed to be installed when the gating snap is installed on a device. For example, specify that if the roadmr-gating snap is installed, the roadmr-gated snap can only be installed or refreshed to revision 2.\n\n```text\n$ snapcraft validate roadmr-gating roadmr-gated=2 --key-name my-key\nGetting details for roadmr-gated\nSigning validations assertion for roadmr-gated=2\n```\n\nThis generates the assertion and pushes it to the assertions service. A copy of the assertion will also be left on the current directory.\n\n```text\ntype: validation\nauthority-id: Q8HSISyvcdrniz52oa8Qjh6HlZwv0wiT\nseries: 16\nsnap-id: gs2epiCF5LPioNKnajAOTiBhOogG26RN\napproved-snap-id: xZkR9MIMbusYipfJ80DGWf1nPKkD77hk\napproved-snap-revision: 2\nrevoked: false\ntimestamp: 2018-05-30T21:00:04.092765Z\nsign-key-sha3-384: mfomTtPB1cE3IFs51NtdnFoPlQwJxFgxOMU_q0mPkH7M2gKB-4m28d99XrVjA53B\n```\n\nTo verify this was pushed up to assertions service:\n\n\n```text\n$ snap known --remote validation series=16 snap-id=gs2epiCF5LPioNKnajAOTiBhOogG26RN approved-snap-id=xZkR9MIMbusYipfJ80DGWf1nPKkD77hk approved-snap-revision=2\ntype: validation\nauthority-id: Q8HSISyvcdrniz52oa8Qjh6HlZwv0wiT\nseries: 16\nsnap-id: gs2epiCF5LPioNKnajAOTiBhOogG26RN\napproved-snap-id: xZkR9MIMbusYipfJ80DGWf1nPKkD77hk\napproved-snap-revision: 2\nrevoked: false\ntimestamp: 2018-05-30T21:00:04.092765Z\nsign-key-sha3-384: mTVMTtPB1cE3IFs51NtdnFoPlQwJxFgxOMU_q0mPkH7M2gKB-4m28d99XrVjA53B\n....\n```\n\nAs described earlier, this means that, if the gating snap is installed on the system, the gated snap can *only be installed or refreshed to the approved revision* (2 in this case). If the gating snap is not installed on the system, the gated snap is not restricted and will be installable or updatable to whichever revision is available in the requested channel. The revision of the gating snap is not relevant here; what's relevant is the latest validation assertion which tells which revision of roadmr-gated is allowed.\n\nThe snapcraft gated command can tell you which snaps are gated by a particular snap:\n\n```text\n$ snapcraft gated roadmr-gating\nName                Revision  Required    Approved\nroadmr-gated        2         True        2018-05-30T21:00:04Z\n```\n\nHere we can see roadmr-gating, if installed, will constrain roadmr-gated to revision 2 (or nothing at all, if rev2 is not installable).\n\nAt this point one can install the gating snap:\n\n```text\n$ snap install roadmr-gating\nroadmr-gating 2018-05-30-01 from 'snapdeveloper' installed\n$ snap list roadmr-gating\nName           Version        Rev    Tracking    Developer      Notes\nroadmr-gating  2018-05-30-01    1    stable      snapdeveloper  -\n```\n\nNote that trying to install the gated snap fails:\n\n```text\n$ snap install roadmr-gated\nerror: snap \"roadmr-gated\" not found\n```\n\nEven though it is indeed available on stable (but at revision 1, not the validated one, which would be 2):\n\n```text\n$ snap info roadmr-gated\nname:      roadmr-gated\npublisher: snapdeveloper\nsnap-id: xZkR9MIMbusYipfJ80DGWf1nPKkD77hk\nchannels:\n  stable:    2018-05-30-02 (1) 4kB -\n```\n\nOnce revision 2 is published...\n\n```text\n$ snap info roadmr-gated\nname:      roadmr-gated\npublisher: snapdeveloper\nsnap-id: xZkR9MIMbusYipfJ80DGWf1nPKkD77hk\nchannels:\n  stable:    2018-05-30-03 (2) 4kB -\n```\n\n...installing can proceed.\n\n```text\n$ snap install roadmr-gated\nroadmr-gated 2018-05-30-03 from 'snapdeveloper' installed\n$ snap list roadmr-gating roadmr-gated\nName            Version         Rev     Tracking    Developer        Notes\nroadmr-gated    2018-05-30-03   2       stable      snapdeveloper    -\nroadmr-gating   2018-05-30-01   1       stable      snapdeveloper    -\n```\n\nIf at this point revision 3 of the gated snap is published...\n\n```text\n$ snap info roadmr-gated\nname:      roadmr-gated\npublisher: snapdeveloper\nsnap-id:   xZkR9MIMbusYipfJ80DGWf1nPKkD77hk\ntracking:  stable\nrefreshed: 2018-05-30T21:08:53Z\ninstalled:   2018-05-30-03 (2) 4kB -\nchannels:\n  stable:    2018-05-30-04 (3) 4kB -\n```\n\n...snap refresh will do nothing because even though v3 is available, it's not validated.\n\n```text\n$ snap refresh\nAll snaps up to date.\n$ snap list roadmr-gating roadmr-gated\nName            Version         Rev Tracking    Developer        Notes\nroadmr-gated    2018-05-30-03   2   stable      snapdeveloper    -\nroadmr-gating   2018-05-30-01   1   stable      snapdeveloper    -\n```\n\nValidation is independent of snap release/publishing. For example, we can validate the existing gated snap v3 with the existing gating snap at revision 1 (meaning no update of gating snap is needed):\n\n```text\n$ snapcraft validate roadmr-gating roadmr-gated=3 --key-name my-key\nGetting details for roadmr-gated\nSigning validations assertion for roadmr-gated=3\n```\n\nAt this point a refresh will take gated-1 to rev 3 which was validated.\n\n```text\n$ snap refresh\nroadmr-gated 2018-05-30-04 from 'snapdeveloper' refreshed\n$ snap list roadmr-gating roadm"
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## Example gating workflows (part 2)",
    "content": "r-gated\nName            Version       Rev    Tracking   Developer        Notes\nroadmr-gated    2018-05-30-04 3      stable     snapdeveloper    -\nroadmr-gating   2018-05-30-01 1      stable     snapdeveloper    -\n```"
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## Gating multiple snaps",
    "content": "A validation can be issued to restrict the revisions of more than one gated snap (assuming the “publisher setup” was done to allow the gating snap to control the indicated gated snaps):\n\n```text\n$ snapcraft validate roadmr-gating roadmr-gated=2 facundo-gated=5\nGetting details for roadmr-gated\nGetting details for facundo-gated\nSigning validations assertion for roadmr-gated=2\nSigning validations assertion for facundo-gated=5\n```\n\nIn this example, if roadmr-gating is installed on a device, roadmr-gated will only install or refresh to revision 2, and facundo-gated will only install or refresh to revision 5."
  },
  {
    "filepath": "\\build-store\\refresh-control.md",
    "metadata": {
      "title": "Validations and Refresh Control",
      "table_of_contents": true
    },
    "heading": "## Notes",
    "content": "* At the moment, validations can only be issued to gate snaps which have a release on the stable channel _at the moment of creating the validation_. (There’s [a snapcraft bug for this][3]). This is because `snapcraft validate` uses the details API to get the details from the stable channel only, and it doesn’t allow specifying another channel to get the gated snap’s details. Once the validation is in place, validations are channel-agnostic because they operate at the revision level.\n\n```text\n$ snapcraft status gated-1\nTrack    Arch    Channel    Version        Revision\nlatest    amd64  stable     -              -\n                 candidate  -              -\n                 beta       -              -\n                 edge       2018-05-30-04  3\n\n$ snapcraft validate gating-1 gated-1=3\nGetting details for gated-1\nSnap 'gated-1' was not found in the 'stable' channel.\n```\n\n[1]: https://dashboard.snapcraft.io/snaps/whatever/\n[2]: https://docs.ubuntu.com/core/en/reference/assertions/validation\n[3]: https://bugs.launchpad.net/snapcraft/+bug/1775658"
  },
  {
    "filepath": "\\build-store\\reviewer-tools.md",
    "metadata": {
      "title": "Reviewer tools",
      "table_of_contents": true
    },
    "heading": "# Reviewer tools",
    "content": "The reviewer tools are a suite of tests and utilities to help you reviewing packages. Checks that are run by default are equivalent to store default settings."
  },
  {
    "filepath": "\\build-store\\reviewer-tools.md",
    "metadata": {
      "title": "Reviewer tools",
      "table_of_contents": true
    },
    "heading": "## Install the tools",
    "content": "You first need to install the `bzr` package to fetch the source of the tools:\n\n```bash\nsudo apt install bzr\n```\n\nThen, get the tools and set the Python path to the root of the tools directory:\n\n```bash\nbzr branch lp:click-reviewers-tools\ncd ./click-reviewers-tools\nexport PYTHONPATH=./\n```"
  },
  {
    "filepath": "\\build-store\\reviewer-tools.md",
    "metadata": {
      "title": "Reviewer tools",
      "table_of_contents": true
    },
    "heading": "## Run checks locally",
    "content": "The `click-review` binary is the main tool to run checks on snaps. This command takes a path to a local snap as an argument. It does not run the snap but sanity checks its metadata and paths according to the general security policy.\n\n```bash\n$ ./bin/click-review /tmp/foo-snap_1.0_amd64.snap\n```\nIn case of success, `click-review` will print `pass`:\n\n```bash\n$ ./bin/click-review /tmp/foo-snap_1.0_amd64.snap\n/tmp/foo-snap_1.0_amd64.snap: pass\n```\n\nIn case of failure, two categories of issues can be displayed: errors and warnings. Errors block a snap from being released (unless manually approved). For example:\n\n```bash\n$ ./bin/click-review /tmp/foo-snap_1.0_amd64.snap\nErrors\n------\n - lint-snap-v2:confinement_classic\n\t(NEEDS REVIEW) confinement 'classic' not allowed\n - lint-snap-v2:confinement_classic_with_interfaces\n\tconfinement 'classic' not allowed with plugs/slots\n\thttps://launchpad.net/bugs/1655369\nWarnings\n--------\n - lint-snap-v2:meta_gui_desktop\n\tdesktop interfaces (x11) specified without meta/gui/*.desktop. Please provide a desktop file via setup/gui/*.desktop if using snapcraft or meta/gui/*.desktop otherwise. It should reference one of the 'apps' from your snapcraft/snap.yaml.\n```\n\nYou can then:\n\n* ask the uploader to remove or change the offending code\n* reject the snap\n* approve the snap anyway\n* edit its `snap-declaration` assertion to make it conform to your security policies or to adapt it to your users needs.\n\n[//]: <> (TODO: Test a snap in a virtual machine)"
  },
  {
    "filepath": "\\build-store\\reviewer-tools.md",
    "metadata": {
      "title": "Reviewer tools",
      "table_of_contents": true
    },
    "heading": "## Edit snap declarations",
    "content": "Snap declarations allow reviewers to enable specific features on snaps, such as allowing auto-connections of interfaces and setting up automated aliases for snap commands.\n\nTheir content needs to be provided in JSON through the reviewer form in the store. To ease this process, you can use the `bin/create-snap-declaration.py` script.\n\nFor example, the `network manager` snap declares: `slots: [ network-manager ]` and `plugs: [ firewall-control, network, network-bind, network-control, network-manager ]`. If all the plugged interfaces for network-manager are meant to be auto-connected and other snaps are to be allowed to connect to the network-manager slot, the reviewer would use:\n\n```bash\n$ ./bin/create-snap-declaration.py --plug-auto-connection=network-control,firewall-control,network-manager,network,network-bind --slot-connection=network-manager\nWARN: adding missing 'installation' for 'network-manager' from base decl\nWARN: adding missing 'auto-connection' for 'network-manager' from base decl\nslots:\n{\n  \"network-manager\": {\n    \"allow-connection\": \"true\",\n    \"allow-installation\": {\n      \"slot-snap-type\": [\n        \"app\",\n        \"core\"\n      ]\n    },\n    \"deny-auto-connection\": \"true\"\n  }\n}\nplugs:\n{\n  \"firewall-control\": {\n    \"allow-auto-connection\": \"true\"\n  },\n  \"network\": {\n    \"allow-auto-connection\": \"true\"\n  },\n  \"network-bind\": {\n    \"allow-auto-connection\": \"true\"\n  },\n  \"network-control\": {\n    \"allow-auto-connection\": \"true\"\n  },\n  \"network-manager\": {\n    \"allow-auto-connection\": \"true\"\n  }\n}\n```\n\nThen paste the output into the reviewer form."
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "# Reviews",
    "content": "If you haven't disabled it in the [store settings](settings.md), snaps reviews are run automatically. They consist of linting and security policy checks, using a set of reviewer tools, which can be installed and used locally if you need to do an in-depth manual review or override a snap declaration (see below for details).\n\nAll snaps pending reviews can be found in the [review queue](https://dashboard.snapcraft.io/dev/snaps/reviewer/\n) store page."
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "## Adding reviewers",
    "content": "As of now, to add reviewers, you need to get in touch with the Store team. The only prerequisite to add reviewers is to ensure they have [created a store account](https://dashboard.snapcraft.io) beforehand.\n\nSee the [Report an issue section](issues.md) for contact details."
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "## How to review",
    "content": "The role of a reviewer is to periodically:\n\n* Examine the [review queue](https://dashboard.snapcraft.io/dev/snaps/reviewer/\n) and select an app to be reviewed\n* Check to see if there are any warnings or errors in the review output\n  * If the error is for an interface restriction or [`confinement: classic`](https://snapcraft.io/docs/reference/confinement) and you deem it is acceptable to grant: update the snap declaration on the store, leave a comment as to why it was granted, then click 'Run the automated review again'. This should now pass automated review\n    * **IMPORTANT**: there are defined processes for providing snap declarations that must be followed (see below)\n* If overriding warnings or errors, leave a comment to the developer as to why and how to avoid this error/warning in the future and click 'Approve'\n* If rejecting, leave a comment to the developer as to how to fix the error/warning and click 'Reject'\n* If need more information, ask the question in the comment section and click 'Ask for information'"
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "## Snap declarations",
    "content": "Snapd, the daemon that powers snaps on a system, uses snap declarations to check for installation, interface connection and interface auto-connection. Snap declarations are text files generated and signed by the store that ensure communication of policies and ownership between stores and clients.\n\nIn essence, a base declaration defines all the available interfaces and when they are installable, connectable or auto-connectable (see below for details). The store uses the base declaration to prompt for manual review or not. A reviewer may override the base declaration with a snap declaration. The store provides a form that allows enabling/disabling (auto-)connection of the declared interfaces that will update the declaration accordingly. The snap declaration applies to all revisions for that snap.\n\nImportantly, if a snap declaration is specified, it overrides the base declaration constraints (eg, installation, connection, auto-connection) and the base declaration is not consulted."
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "## Review criteria",
    "content": "There are three important checkpoints to consider when reviewing snaps: confinement, interfaces and aliases.\n\n* Confinement defines the read and write access a snap can have on a system. There are three confinement policies: `strict`, `devmode` and `classic`.\n* Interfaces provide snaps extra access to the system and the base declaration is written to reflect the scope of that access.\n* Aliases provide familiarity for snaps users by aliasing a snap command to another name. They are declared inside snaps by developers and it's up to reviewers to enable auto-aliasing of these commands upon install.\n\n[//]: <> (### Confinement)"
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "### Interfaces",
    "content": "The base declaration general policy is as follow:\n\n* If the interface gives elevated privileges to a snap on the user machine, it requires a manual connection at the user discretion.\n* If the interface requires a manual connection, it is automatically approved in the store.\n* If the interface is useful to most snaps and doesn't give elevated privileges on the user machine, it is automatically approved in the store and automatically connected upon install on the user machine.\n\nYou can get more details on the status and purpose of existing interfaces by going through the [snap interfaces list](https://snapcraft.io/docs/reference/interfaces).\n\n[//]: <> (### Aliases)"
  },
  {
    "filepath": "\\build-store\\reviews.md",
    "metadata": {
      "title": "Reviews",
      "table_of_contents": true
    },
    "heading": "### Your own criteria",
    "content": "Brand stores are in control of their brand-only snaps and their brand's reputation, therefore brand store reviewers may use whatever criteria that make sense for the brand."
  },
  {
    "filepath": "\\build-store\\settings.md",
    "metadata": {
      "title": "Settings",
      "table_of_contents": true
    },
    "heading": "# Settings",
    "content": "You can manage your store settings through the [Store Preferences](https://dashboard.snapcraft.io/dev/store/admin/) page.\n\nThere are three categories of settings:\n\n* Store preferences\n* Automatic review checks\n* Available store packages"
  },
  {
    "filepath": "\\build-store\\settings.md",
    "metadata": {
      "title": "Settings",
      "table_of_contents": true
    },
    "heading": "## Store preferences",
    "content": "* \"Can sell apps\": you can enable or disable paid apps in your store.\n\n    When enabled, uploaders have the possibility to set a price for their apps and end users can use the `snap buy` command to buy them, allowing their installation on devices logged in with the account that bought them.\n\n* \"Unlisted\": this makes the store semi-private. The name and store id will not be listed in the main [store list](https://dashboard.snapcraft.io/dev/store/list/), but will still be accessible to clients and uploaders who know its id.\n\n* \"Add packages to this store\": you can add snaps from other public stores to your store\n\n    When clicking on this option you will be presented with a list of snaps from other public stores or other stores you are administrator of that you can select to be included in your store."
  },
  {
    "filepath": "\\build-store\\settings.md",
    "metadata": {
      "title": "Settings",
      "table_of_contents": true
    },
    "heading": "## Automatic review checks",
    "content": "* \"Manual approval\": the first setting of this category enforces manual approval on all snaps, regardless of the results of the automated review."
  },
  {
    "filepath": "\\build-store\\settings.md",
    "metadata": {
      "title": "Settings",
      "table_of_contents": true
    },
    "heading": "### Review types",
    "content": "The store allows you to be very granular in which automatic checks you can disable. Each of these is defined in the `click-reviewer-tools` [source code](http://bazaar.launchpad.net/~store-reviewers/click-reviewers-tools/trunk/files) and included test suite."
  },
  {
    "filepath": "\\build-store\\upload-snaps.md",
    "metadata": {
      "title": "Upload snaps",
      "table_of_contents": true
    },
    "heading": "# Upload snaps",
    "content": "By default, snapcraft will upload snaps to the main snap store. To change this behaviour and upload snaps to a specific brand store, you need to:\n\n1. Know the id of the store your are targeting, which is available in the [Store List](https://dashboard.snapcraft.io/dev/store/list/) page, which lists stores you can upload to or manage\n* Pass it to snapcraft through the `SNAPCRAFT_UBUNTU_STORE` environment variable"
  },
  {
    "filepath": "\\build-store\\upload-snaps.md",
    "metadata": {
      "title": "Upload snaps",
      "table_of_contents": true
    },
    "heading": "## Example",
    "content": "```bash\n$ export SNAPCRAFT_UBUNTU_STORE=<store id>\n```\n\nThen, you can register names for your snaps, push and release them:\n\n```bash"
  },
  {
    "filepath": "\\build-store\\upload-snaps.md",
    "metadata": {
      "title": "Upload snaps",
      "table_of_contents": true
    },
    "heading": "# snapcraft register <snap name>",
    "content": "$  snapcraft register my-app"
  },
  {
    "filepath": "\\build-store\\upload-snaps.md",
    "metadata": {
      "title": "Upload snaps",
      "table_of_contents": true
    },
    "heading": "# snapcraft push <snap file>",
    "content": "$ snapcraft push my-app"
  },
  {
    "filepath": "\\build-store\\upload-snaps.md",
    "metadata": {
      "title": "Upload snaps",
      "table_of_contents": true
    },
    "heading": "# snapcraft release <snap name> <revision> <track/channel>",
    "content": "$ snapcraft release my-app 12 latest/stable\n```\n\nIf this is your first time with snapcraft, have a look at [this step-by-step tutorial](https://snapcraft.io/docs/build-snaps/publish) that will guide you through the publication process."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "# Board enablement overview",
    "content": "This document will walk you through all the steps to enable an unsupported board and build an Ubuntu Core image for it.\n\nYou will learn how to:\n\n* [Create a kernel snap](#the-kernel-snap)\n* [Create a gadget snap](#the-gadget-snap)\n* [Create a model assertion](#the-model-assertion)\n* [Build an image](#image-building)\n\nNote: this documentation has been tested and performed on Roseapple Pi, you can find the complete example source in [this repository](https://github.com/kubiko/roseapple-pi-ubuntuCore-build)."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "## The kernel snap",
    "content": "Ubuntu Core kernels are based on the `multiv7_defconfig` plus some mandatory Ubuntu configs (see the `snapcraft.yaml` example below).\n\nYou can find reference kernels here: [https://github.com/snapcore/sample-kernels](https://github.com/snapcore/sample-kernels)\n\nOnce you have a kernel ready for Ubuntu core, the recommended way to build a kernel is with [snapcraft](http://snapcraft.io). Preferably host the `snapcraft.yaml` for the kernel in your device build tree, independent of the kernel tree."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### Kernel `snapcraft.yaml` example",
    "content": "[Source](https://github.com/kubiko/roseapple-pi-ubuntuCore-build/blob/master/builder/kernel/snapcraft.yaml)\n\n    name: roseapple-pi-kernel\n    version: 3.10.37-1\n    summary: A roseapple kernel built from source\n    description: This is the reference kernel from xapp-le branch Ubuntu-Snappy-Core\n    type: kernel\n    architectures: [ armhf ]\n\n    parts:\n        kernel:\n            plugin: kernel\n            source: https://github.com/kubiko/kernel-roseapple-pi.git\n            source-branch: Ubuntu-Snappy-Core\n            source-type: git\n            kdefconfig: [snappy-actduino_bubble_gum_linux_defconfig]\n            kconfigs:\n                - CONFIG_LOCALVERSION=\"-roseapple\"\n                - CONFIG_DEBUG_INFO=n\n                - CONFIG_SQUASHFS=m\n                - CONFIG_DEVPTS_MULTIPLE_INSTANCES=y\n                - CONFIG_RTL8192U=m\n                - CONFIG_BT_BCM=m\n                - CONFIG_MAC80211_LEDS=y\n                - CONFIG_RFKILL_LEDS=y\n                - CONFIG_ATH_COMMON=y\n                - CONFIG_ATH_CARDS=y\n                - CONFIG_ATH9K_HW=y\n                - CONFIG_ATH9K_COMMON=y\n                - CONFIG_ATH9K_BTCOEX_SUPPORT=y\n                - CONFIG_ATH9K_HTC=y\n                - CONFIG_ATH9K_HTC_DEBUGFS=y\n                - CONFIG_LEDS_TRIGGERS=y\n\n            kernel-initrd-modules:\n                - squashfs\n            kernel-image-target: zImage\n            kernel-device-trees:\n                - actduino_bubble_gum_sdboot_linux\n            build-packages: [bc, kmod, cpio]"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "## The gadget snap",
    "content": "The [gadget snap](../../guides/build-device/gadget.html) is a key snap for device boot, as it contains the description of the boot and file system layout, which is then used for image building.\n\nYou will need to create two files in the `meta` directory of this snap:\n\n* `meta/snap.yaml` containing the basic device description, together with device specific interfaces if needed\n* `meta/gadget.yaml` describing the device boot mode and its filesystem layout."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### `meta/snap.yaml` example",
    "content": "name: roseapple-pi\n    version: 16.04-1\n    summary: Roseapple Pi support package\n    description: |\n     Support files for booting Roseapple Pi\n    type: gadget\n    architectures:\n        - armhf"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### `meta/gadget.yaml` example",
    "content": "device-tree: actduino_bubble_gum_sdboot_linux.dtb\n        volumes:\n          roseapplepi:\n            schema: mbr\n            bootloader: u-boot\n            structure:\n              - offset: 2097152 #4096*512\n                size: 2097152 #2M\n                type: mbr\n                content:\n                    - image: boot-assets/bootloader.bin\n                      offset: 512 #(4097-4096)*512\n                    - image: boot-assets/u-boot.bin\n                      offset: 1048576 #(6144-4096)*512\n              - type: 0C\n                filesystem: vfat\n                filesystem-label: system-boot\n                size: 128M\n                content:\n                  - source: boot-assets/\n                    target: /\n\nAs of writing, snapcraft does not support native gadget building, you can snap it by running:\n\n    snapcraft snap <directory with gadget snap content>"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "## The model assertion",
    "content": "Before you can build an image to flash on the board, you need to prepare a [model assertion](../../reference/assertions.html) and sign it.\n\nFirst, prepare a JSON file describing the model assertion:"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### Example model assertion for a Roseapple Pi",
    "content": "{\n      \"type\": \"model\",\n      \"authority-id\": \"<your store account id>\",\n      \"brand-id\": \"<your store account id>\",\n      \"series\": \"16\",\n      \"model\": \"roseapple\",\n      \"architecture\": \"armhf\",\n      \"gadget\": \"roseapple-pi\",\n      \"kernel\": \"roseapple-pi-kernel\",\n      \"timestamp\": \"<timestamp>\"\n    }"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "##### Keys description",
    "content": "*   `type`: the assertion type you are creating\n*   `authority-id`, `brand-id` refer to your store account id. You will find it on [your account page](https://dashboard.snapcraft.io/dev/account/), in the `Account-Id` field.\n*   `series`: the Ubuntu Core series in use\n*   `model`: a free form lower-case name for your target device\n*   `architecture`: the architecture of the device you are building the image for\n*   The `gadget` and `kernel` values refer to the name of your kernel and gadget snaps\n*   `timestamp` is a valid timestamp you need to generate using the `date -Iseconds --utc` command\n\nAdditional supported keywords for model assertion are:\n\n- `required-snaps`: list of strings describing the list of additional snaps to be preinstalled\n- `core`: define a custom core snap that needs to be used"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "### Sign the model assertion",
    "content": "Before signing the model, you need to have a valid key registered with your store account. Make sure the `snapcraft` and `snap` commands know about you by logging in using the email address attached to your account.\n\n    snapcraft login\n    snap login you@yourdomain.com\n\nNote that `logout` commands are available as well.\n\nTo check for keys on your machine, run\n\n    snap keys\n\nFor backup purposes, snap keys are stored under `~/.snap/gnupg`"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### Key creation",
    "content": "If you do not have a key, create a new one. You can pass an optional name for the key. If you don't, the key name will be `default`.\n\n    snap create-key my-key\n\nThen, register the key with your store account:\n\n    snapcraft register-key my-key"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### Signature step",
    "content": "Now you have to sign the model assertion with your key, by piping your JSON model through the `snap sign -k <key name>` command and outputting a model file you will use to build your image.\n\n    cat roseapple-model.json | snap sign -k my-key &> roseapple.model\n\nYou can find a more detailed example of this process on the [custom image building](../../guides/build-device/image-building.html) page."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### Canonical signed assertions",
    "content": "Alternatively, if you just want to build an image using a kernel and gadget snaps signed by Canonical, you can use Canonical signed model assertions. Assertions for Canonical supported boards can be fetched from the Ubuntu store, for example:\n\n    curl -H \"Accept: application/x.ubuntu.assertion\" \"https://assertions.ubuntu.com/v1/assertions/model/16/canonical/pc-amd64\"\n\nOr\n\n    curl -H \"Accept: application/x.ubuntu.assertion\" \"https://assertions.ubuntu.com/v1/assertions/model/16/canonical/pi3\"\n\nIf you are running on system with snapd, you can also use the following command:\n\n    snap known --remote model series=16 brand-id=canonical model=pc-amd64\n\nOr\n\n    snap known --remote model series=16 brand-id=canonical model=pi3"
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "## Image building",
    "content": "Ubuntu Core images are built using the `ubuntu-image` command.\n\nUbuntu image is in beta. You can install it from the store with:\n\n    snap install --beta --devmode ubuntu-image\n\nThis snap will not auto-update, so if want to get the latest version of `ubuntu-image`, run periodically:\n\n    snap refresh --beta --devmode ubuntu-image\n\nYou can now build your image using the following command:\n\n    sudo ubuntu-image \\\n    -c stable \\        # available channels are: edge/beta/candidate/stable\n    --image-size 4G \\\n    --extra-snaps <gadget snap file name, e.g. roseapple-pi_16.04-1_armhf.snap> \\\n    --extra-snaps <kernel snap file name, e.g. roseapple-pi-kernel_3.10.37-1_armhf.snap> \\\n    --extra-snaps <add more preinstalled snaps here, names from the store or local paths>\n    -o <image output file name, e.g. roseapple-pi-20161107-0.img>\n    <model file name, e.g. roseapple.model>\n\nNote: The `--extra-snaps` argument takes either a snap name accessible from the store or a local path to a built snap.\n\nYour image is ready, you can use a tool like `dd` to write the image to an SD Card and boot your board."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "### Build a custom image for a reference board",
    "content": "To build a custom image for one of the Canonical supported boards, use a Canonical signed model assertion, as described above and use a gadget and kernel snaps from the store."
  },
  {
    "filepath": "\\guides\\build-device\\board-enablement.md",
    "metadata": {
      "title": "Board enablement overview",
      "table_of_contents": true
    },
    "heading": "#### Example for a custom Raspberry Pi3 image",
    "content": "curl -H \"Accept: application/x.ubuntu.assertion\" \"https://assertions.ubuntu.com/v1/assertions/model/16/canonical/pi3\" > pi3.model\n\n    sudo ubuntu-image \\\n    -c stable \\\n    --image-size 4G \\\n    --extra-snaps pi2-kernel \\\n    --extra-snaps pi3 \\\n    --extra-snaps nextcloud \\\n    -o pi3-20161107-0.img \\\n    pi3.model"
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "## Overview",
    "content": "There are a number of situations where snapd needs to notify a snap that\nsomething has happened. For example, when a snap is upgraded, it may need to run\nsome sort of migration on the previous version's data in order to make it\nconsumable by the new version. Or when an interface is connected or\ndisconnected, the snap might need to obtain attributes specific to that\nconnection. These types of situations are handled by hooks."
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "## General usage",
    "content": "A hook is defined as an executable contained within the `meta/hooks/` directory\ninside the snap. The file name of the executable is the name of the hook (e.g.\nthe `upgrade` hook executable would be `meta/hooks/upgrade`).\n\nAs long as the file name of the executable corresponds to a supported hook name,\nthat's all one needs to do in order to utilize a hook within their snap. Note\nthat hooks, like apps, are executed within a confined environment. By default\nhooks will run with no plugs; if a hook needs more privileges one can use the\ntop-level attribute `hooks` in `snap.yaml` to request plugs, like so:\n\n    hooks: # Top-level YAML attribute, parallel to `apps`\n        upgrade: # Hook name, corresponds to executable name\n            plugs: [network] # Or any other plugs required by this hook\n\nNote that hooks will be called with no parameters. If they need more information\nfrom snapd (or need to provide information to snapd) they can utilize the\n`snapctl` command (for more information on `snapctl`, see `snapctl -h`)."
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "## Supported Hooks",
    "content": "**Note:** The development of specific hooks is ongoing."
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "### `configure`",
    "content": "The `configure` hook is called upon initial install, upgrade, and whenever the user requests a configuration change via the `snap set` command. The hook should use `snapctl get` to retrieve the requested configuration from snapd, and act upon it. If it exits non-zero, the configuration will not be applied."
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "#### `configure` example",
    "content": "Say the user runs:\n\n```bash\nsnap set <snapname> username=foo password=bar\n```\n\nThe `configure` hook would be located within the snap at `meta/hooks/configure`.\nAn example of what it might contain is:\n\n```bash\n#!/bin/sh\n\nif ! username=$(snapctl get username); then\n    echo \"Username is required\"\n    exit 1\nfi\n\nif ! password=$(snapctl get password); then\n    echo \"Password is required\"\n    exit 1\nfi"
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "# Handle username and password, perhaps write to a credential file of some sort.",
    "content": "echo \"user=$username\" > $SNAP_DATA/credentials\necho \"password=$password\" >> $SNAP_DATA/credentials\nchmod 600 $SNAP_DATA/credentials\n```"
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "### `prepare-device` (gadget snap specific)",
    "content": "The optional `prepare-device` hook will be called on the gadget if\npresent at the start of the device initialization process, once the\ndevice has first booted and the gadget snap has been installed. The\nhook will also be called if this process is retried later from scratch\nin case of initialization failures.\n\nThe device initialization process is for example responsible of\nsetting the serial identification of the device through an exchange\nwith a device service. The `prepare-device` hook can for example\nredirect this exchange and dynamically set options relevant to it."
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "#### `prepare-device` example",
    "content": "```bash\n#!/bin/sh"
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "# optionally set the url of the service",
    "content": "snapctl set device-service.url=\"https://device-service\""
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "# set optional extra HTTP headers for requests to the service",
    "content": "snapctl set device-service.headers='{\"token\": \"TOKEN\"}'"
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "# this might need to be obtained dynamically",
    "content": "snapctl set registration.proposed-serial=\"DEVICE-SERIAL\""
  },
  {
    "filepath": "\\guides\\build-device\\config-hooks.md",
    "metadata": {
      "title": "Configuration and Hooks",
      "table_of_contents": true
    },
    "heading": "# this might need to be obtained dynamically",
    "content": "snapctl set registration.body='mac: \"00:00:00:00:ff:00\"'\n\n```"
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "## Overview",
    "content": "The _gadget_ snap is responsible for defining and manipulating the system properties which are specific to one or more devices that will usually look similar to one another from an implementation perspective. This snap must necessarily be produced and signed by the device brand, which is defined via the model assertion. The brand knows where and how that device will be used, and designs the gadget snap accordingly.\n\nFor example, the brand may know that the device is actually a special VM to be used on a particular cloud, or it may know that it is going to be manufactured in a particular factory. The gadget snap may encode the mechanisms for device initialization - key generation and identity certification - as well as particular processes for the lifecycle of the device, such as factory resets. It is perfectly possible for different models to share a gadget snap.\n\n[Syntax and composition of a gadget snap &rsaquo;](../../reference/gadget.md)"
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "## Reference gadget snaps",
    "content": "Canonical publishes [reference gadget snaps](../../reference/gadget.html#examples-of-production-ready-gagdet-snaps) as well as gadget snaps for main Canonical models such as official Ubuntu Core VMs on various certified public clouds, as well as general purpose computing images for popular physical devices like the 64-bit x86 PC and Raspberry Pi 2 and 3."
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "## The `prepare-device` hook",
    "content": "The optional `prepare-device` [hook](config-hooks.html) is a script that will be called on the gadget at the start of the device initialization process, after the gadget snap has been installed. The hook will also be called if this process is retried\nlater from scratch in case of initialization failures.\n\nThe device initialization process is for example responsible of setting\nthe serial identification of the device through an exchange with a\ndevice service. The `prepare-device` hook can for example redirect this\nexchange and dynamically set options relevant to it.\n\nLike other hooks, the script should be an executable with the name of the hook triggering it and be in the `meta/hooks/` directory of your snap."
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "### Example",
    "content": "```bash\n#!/bin/sh"
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "# optionally set the url of the service",
    "content": "snapctl set device-service.url=\"https://device-service\""
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "# set optional extra HTTP headers for requests to the service",
    "content": "snapctl set device-service.headers='{\"token\": \"TOKEN\"}'"
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "# this might need to be obtained dynamically",
    "content": "snapctl set registration.proposed-serial=\"DEVICE-SERIAL\""
  },
  {
    "filepath": "\\guides\\build-device\\gadget.md",
    "metadata": {
      "title": "Gadget snaps",
      "table_of_contents": true
    },
    "heading": "# this might need to be obtained dynamically",
    "content": "snapctl set registration.body='mac: \"00:00:00:00:ff:00\"'\n\n```"
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "# Ubuntu Core images",
    "content": "For [supported devices](https://developer.ubuntu.com/core/get-started), there are official Ubuntu Core images for both [Core 18](http://cdimage.ubuntu.com/ubuntu-core/18/stable/) and [Core 16](http://cdimage.ubuntu.com/ubuntu-core/16/stable/)."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "## Build a custom Ubuntu Core image",
    "content": "This document will walk you through the steps needed to build either a Core 18 or Core 16 image for a device family. You will learn how to:\n\n*   Create and upload a snapcraft key to the store\n*   Create a model assertion for your target device\n*   Compose and build a custom image using the `ubuntu-image` command\n\nIf you want to build an Ubuntu Core image for a device family that is not already supported, please follow the [Board enablement overview](../../guides/build-device/board-enablement.html) document."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "## Snapcraft keys",
    "content": "Before starting, you need to create a key to sign your future store uploads."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### 1. Create a key",
    "content": "To generate a key that can then be linked to your Ubuntu Store account, run the following:\n\n```bash\nsnapcraft create-key\n```\n\nYou can pass an optional name for the key:\n\n```bash\nsnapcraft create-key foo\n```\n\nThe *create-key* command will ask you for a password to protect the key.\n\nGenerating the key will take some time because it's creating a 4096 bit long key that needs some entropy to complete. Moving the mouse or typing can help to speed up the process, as will installing the `rng-tools` package beforehand.\n\nNow, you can list your keys with:\n\n```bash\nsnapcraft list-keys\n```\n\nYour keys are located within *~/.snap/gnupg*, and it's a good idea to keep a backup of this directory."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### 2. Register the key with the store",
    "content": "With the key created, you now need to register it with the store, effectively linking it to your account. During this step, you will be asked to select an existing key (if you have more than one) and log in with your store account credentials:\n\n```\nsnapcraft register-key\n```\n\nThe key is now registered with the store and you can start the actual image building."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "## Image building",
    "content": "An Ubuntu Core image is composed of at least three snaps installed together: OS, gadget and kernel.\n\n*   The OS snap contains *Ubuntu Core* itself and will be downloaded during image creation.\n*   The kernel and gadget snaps are layers to personalise or enable your target device. They can be locally built or pulled from the store if they already exist.\n\nA *model assertion*, defined within a JSON-formatted file and consumed by the build process, is used to configure your image."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### 1. Create a model assertion",
    "content": "To build an image, it is required you have a signed model assertion."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### Example",
    "content": "The following is an example model assertion that builds a Core 18 image for a Raspberry Pi 3 board. The JSON file is named `pi3-model.json`:\n\n```json\n{\n  \"type\": \"model\",\n  \"authority-id\": \"<your account id>\",\n  \"brand-id\": \"<your account id>\",\n  \"series\": \"16\",\n  \"model\": \"my-pi3\",\n  \"architecture\": \"armhf\",\n  \"base\": \"core18\",\n  \"gadget\": \"pi=18-pi3\",\n  \"kernel\": \"pi-kernel=18-pi3\",\n  \"timestamp\": \"<timestamp>\"\n}\n```\n\n*   `authority-id` and `brand-id` are your Ubuntu SSO account ID. See [your account page](https://dashboard.snapcraft.io/dev/account/), in the `Account-Id` field.\n*   `series`: the version of the assertion format, and snap namespaces, being used. Later series are backwards compatible.\n*   `model`: a free form lower-case name for your target device. \n*   `architecture`: the architecture of the device you are building the image for.\n*   `base`: the runtime environment to use.\n*   `gadget` and `kernel` refer to snaps already existing in the store or in the current directory.\n*   `=18-pi3`, appended to *gadget* and *kernel*, defines the channel to track. For the universal *pi* snaps, these denote channels for specific models.\n*   `timestamp` is a valid timestamp you need to generate using the `date -Iseconds --utc` command. The timestamp must be later than when the key that signs the model was registered.\n*   `required-snaps`: you can optionally add a list of required snaps that will be unremovable and will be downloaded from the store or locally if they exist in the current directory\n\nTo alternatively build an Ubuntu Core 16 image, replace the `base`, `gadget` and `kernel` lines with the following:\n\n```json\n  \"gadget\": \"pi3\",\n  \"kernel\": \"pi2-kernel\",\n```\n\n**Note**: There are additional requirements when the image targets a Brand Store. Use your Brand SSO Account's account-id in the `authority-id` and `brand-id` fields. Also add a `store` key whose value is your Brand `store-id`."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### 2. Sign your model assertion",
    "content": "Now you have to sign the model assertion with a key by piping your JSON model through the `snap sign -k <key name>` command. The output is the assertion document you will use to build your image.\n\n**Note**: If the model is for a Brand Store, the key must be registered by the Brand SSO Account. \n\n```bash\ncat pi3-model.json | snap sign -k default &> pi3.model\n```\n\nThis command will ask you for the password used when you created the key.\n\nYou can check the signing process has worked by ensuring the signed key has been appended to *pi3.model*."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### 3. Build the image",
    "content": "You can now create your image with the `ubuntu-image` tool. To install it, run:\n\n```bash\nsnap install --classic ubuntu-image\n```\n\nThen, create the image:\n\n```bash\nsudo ubuntu-image -c beta -O pi3-test pi3.model\n```"
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "#### Arguments",
    "content": "*   `-c`: the channel snaps are downloaded from\n*   `-O`: a directory for generated files\n\nYou can include specific snaps pre-installed by default in the image by using the `--extra-snaps` argument. For example:\n\n```bash\nsudo ubuntu-image -c beta --extra-snaps rocketchat-server --extra-snaps nextcloud -o pi3-test.img pi3.model\n```\n\nNote: The `--extra-snaps` argument takes either a snap name accessible from the store or a local path to a built snap."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "### 4. Your image is ready",
    "content": "You can use a tool like `dd` to write the image to an SD card and boot your device (replace *sdXX* with the node for your storage device):\n\n```bash\nsudo dd if=pi3-test/pi3.img of=/dev/sdXX bs=32M\nsync\n```"
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "#### First boot tips",
    "content": "*   On the first boot you have to sign in with a valid Store account to make use of the device.\n*   `console-conf` will download the SSH key registered with your Store account and configure it so you can log into the device via `ssh <account name>@<device address>` without a password.\n*   There is no default `ubuntu` user on these images, but you can run `sudo passwd <account name>` to set a password in case you need a local console login."
  },
  {
    "filepath": "\\guides\\build-device\\image-building.md",
    "metadata": {
      "title": "Ubuntu Core images",
      "table_of_contents": true
    },
    "heading": "#### Known problems and limitations:",
    "content": "*   You need a monitor or a serial cable plugged to the device to be able to go through the first use setup process handled by `console-conf`."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "# Advanced production model",
    "content": "Here we provide an overview of the advanced production model:\n\n* You define your own device type and hence have one or more of:\n    * A kernel snap of you choice. See the [board enablement overview](../build-device/board-enablement.html) for details.\n    * A gadget snap that you have created. See the [board enablement overview](../build-device/board-enablement.html) for details.\n    * A factory image that contains snaps that are not publicly available\n* You curate your own store of snaps, a [Brand store](../../build-store)\n* You want _Update Control_, to decide when updates are published to devices you have created\n\nThey provide all the functionality and control required to manage your device ecosystem.\n\n![\"Advanced Production Model\"](../../../media/production-model-rich.png)"
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Steps",
    "content": "The high level steps for this production model are:\n\n1. Contact your Canonical representative to:\n    * Create you a _Brand Account_\n    * Create your _[Brand store](../../build-store)_ associated with this account\n    * Provide instructions on tools and process needed for manufacturing\n1. Create your gadget snap and publish it in your store\n1. Create the extra snaps needed for your device's base functionality and publish them in your store\n1. Create a _model assertion_ and sign it using a key you have registered with the store\n1. Create your device image (including your extra snaps) using the _signed model assertion_\n1. Flash your image to your devices at your production facility / factory\n1. Perform an initial boot of the device in the factory to get a _signed serial assertion_ from a _Serial Vault_\n1. Distribute your devices to the consumer\n\nLet's take a closer look at some these steps."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Create your gadget snap",
    "content": "The reference section contains detailed information about the format of a gadget snap: [Gadget Snap Format](../../reference/gadget.html)\n\nOf particular importance is the prepare-device hook which must contain the details how to contact your Serial Vault (see later section)."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Create the extra snaps",
    "content": "Once your snap is working as expected, publish it to the brand store. These snaps will only be available to devices whose model assertion specifies your brand and store.\n\nDetailed information about building snap packages can be found on [snapcraft.io](http://snapcraft.io)."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Create a model assertion",
    "content": "Steps for creating a signed model assertion are provided [here](../build-device/image-building).\n\nLet's look at a sample of the JSON file used as input when creating a model assertion for a fictional device, the \"Device 1\", made by the brand \"ACME Corp\". The host architecture is armhf. The image will be populated with the gadget and kernel snaps that support this hardware, the core snap, and two extra snaps required for the device to function correctly, \"acme-dashboard\" and \"acme-control-plane\". Note that the `authority-id` and `brand-id` match the `account-id` defined for the ACME Corp account.\n\n    {\n      \"type\": \"model\",\n      \"authority-id\": \"acme\",\n      \"brand-id\": \"acme\",\n      \"store\": \"abcdef123456789\"\n      \"series\": \"16\",\n      \"model\": \"acme-device-1\",\n      \"architecture\": \"armhf\",\n      \"gadget\": \"device-1\",\n      \"kernel\": \"device-1-kernel\",\n      \"required-snaps\": [\"acme-dashboard\", \"acme-control-plane\"],\n      \"timestamp\": \"2016-12-01T12:00:00+00:00\"\n    }\n\nAs noted in the image building documentation, you sign it with your registered key, which produces your signed model assertion file, which is used in the next step to build your image."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Build the image",
    "content": "Steps for creating an image from the signed model assertion are found [here](../build-device/image-building)."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Factory flash you device",
    "content": "The process requires a serial assertion signed by your brand account. To support you in managing you keys and signing the serial assertion during the production process Canonical have developed an open source tool called the [Serial Vault](http://github.com/ubuntu-core/identity-vault).\n\nThe Serial Vault allows you to make sure the device leaves production ready to communicate with the brand store and gives you confidence that only devices produced by you have access to your snaps."
  },
  {
    "filepath": "\\guides\\go-to-production\\advanced.md",
    "metadata": {
      "title": "Advanced production model - Brand store",
      "table_of_contents": true
    },
    "heading": "## Distribute your devices",
    "content": "When your devices are in the field and operational they will communicate with your brand store to identify when updates are available or to install snaps that the user wants."
  },
  {
    "filepath": "\\guides\\go-to-production\\intro.md",
    "metadata": {
      "title": "Introduction",
      "table_of_contents": true
    },
    "heading": "# Introduction",
    "content": "Making a smart doorbell from Ubuntu Core for your family and friends is undeniably awesome! At some point you may want to take your superb creation into production.\n\nSo: how does one take their brilliant Snap image into production with updatable snaps from a store? Not surprisingly, there is more than one way.\n\nHere, we introduce two _production models_. One simple, one advanced.\n\nLet's dive into the overviews."
  },
  {
    "filepath": "\\guides\\go-to-production\\intro.md",
    "metadata": {
      "title": "Introduction",
      "table_of_contents": true
    },
    "heading": "## Simple production model overview",
    "content": "The first production model is simple. It's a good choice when you publish your extra snaps (those that make the device compelling and unique) for free in the Ubuntu Store and you base your image on unmodified snaps (kernel, gadget, and core). Your device in the field gets updates, including updates of your extra snaps that you included in the image.\n\nOne key limitation of the simple model is that you cannot have a a brand store. The devices all point to the base Ubuntu Store.\n\nFor a closer look, see [simple production model](simple.md)."
  },
  {
    "filepath": "\\guides\\go-to-production\\intro.md",
    "metadata": {
      "title": "Introduction",
      "table_of_contents": true
    },
    "heading": "## Advanced production model overview",
    "content": "The second production model fits a range of additional cases. For example:\n\n* You want a brand store to host private snaps for your devices\n* You might use a customized kernel snap or a highly customized gadget snap (the advanced model requires a customized gadget snap but the required customizations are minimal).\n\nThis production model involves a bit more work, but it does offer a much wider range of options.\n\nFor a closer look, see [advanced production model](advanced.md)."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "# Simple production model",
    "content": "Here we provide an overview of the simple production model:\n\n* Your device type is one of the supported device types. See the list on the [Get started](https://developer.ubuntu.com/core/get-started) page of the developer portal.\n* Your device image consists only of snaps that are in the Ubuntu store (not in a branded store subsection)\n* Your image is made from unmodified `core`, `kernel` and `gadget` snaps\n* Your device also includes one or more extra snaps that you have published to the store as freely available (these provide the \"special sauce\" that makes your device unique and awesome)\n* Devices are updated in the field from the Ubuntu store (all snaps are updated as updates become available)\n* Customers can also install snaps from the Ubuntu store\n\nThis is a great choice that provides the simplest path to production.\n\n**Note** If you want your device to connect to a branded section in the Ubuntu store, consider using the [advanced production model](advanced.md)\n\n![\"Simple Production Model\"](../../../media/production-model-simple.png)"
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Steps",
    "content": "The high level steps are few for this production model:\n\n1. Develop your own _extra_ snaps and publish them in the Ubuntu store as freely available\n1. Create a _model assertion_ and sign it using a key you have registered with the store\n1. Create your device image (including your extra snaps) with your signed model assertion\n1. Flash your image onto your devices (the _factory_ stage)\n1. Distribute your devices.\n\nLet's take a closer look at these steps."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Develop and publish your extra snaps",
    "content": "There's no better place than [snapcraft.io](http://snapcraft.io/docs/build-snaps) for learning how to develop snaps.\n\nOnce your snap is working as expected, publish it the store as described [here](http://snapcraft.io/docs/build-snaps/publish).\n\nNext up, you need to create your signed model assertion, then build your image."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Create a signed model assertion",
    "content": "Steps for creating a model assertion are provided [here](../build-device/image-building.html).\n\n**Note** Your model assertion should also contain an additional key \n`required-snaps: ` that lists your extra snaps as a JSON list of strings.\nThese are the snaps that make your device special and help define your model.\n\nHere's a sample model assertion file that defines a model named \"my-pi3\", is armhf, uses the stable (unmodified) gadget, kernel and core snaps (the unmodified core snap is assumed and has no key), contains your extra snaps (\"myawesomesnap\" and \"mysecondawesomesnap\"), and is associated with your store account ID (via the `brand-id` and `authority-id`).\n\n    {\n      \"type\": \"model\",\n      \"authority-id\": \"<your account id>\",\n      \"brand-id\": \"<your account id>\",\n      \"series\": \"16\",\n      \"model\": \"my-pi3\",\n      \"architecture\": \"armhf\",\n      \"gadget\": \"pi3\",\n      \"kernel\": \"pi2-kernel\",\n      \"required-snaps\": [\"myawesomesnap\", \"mysecondawesomenape\"],\n      \"timestamp\": \"<timestamp>\"\n    }\n\nAs noted in the other docs, you sign it with your registered key, which produces a signed model assertion file, which is used in the next step to build your image."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Build the image",
    "content": "Steps for building an image are provided [here](../build-device/image-building.html).\n\n**Note** While the `ubuntu-image` command provides an `extra-snaps` argument, it should not be used to install your special extra snaps, if you don't want them to be removable by the user. Extra snaps that are listed in the model assertion's `required-snaps` field are installed in the image and unremovable.\n\nThe result is an image file that you can flash onto your devices."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Factory: flash your devices",
    "content": "Now, flash your devices with the image file you created. One approach is to use the `dd` command to flash the image to unpartitioned and unmounted SD cards that are destined for the devices. Details here may of course vary depending on your factory process."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Distribute your devices",
    "content": "Obviously, the approach for getting your devices into customers hands in the field is up to you."
  },
  {
    "filepath": "\\guides\\go-to-production\\simple.md",
    "metadata": {
      "title": "Simple production model - Ubuntu store",
      "table_of_contents": true
    },
    "heading": "## Wrap up",
    "content": "Now that your devices are distributed in the field, they are providing unique functionality while protected by the security inherent to Ubuntu Core.\nYour users are getting updates (including security updates) to Canonical snaps (os, kernel, gadget) as they are published in the Ubuntu store, and you can add value by further developing your extra snaps to meet customer needs and pushing updated snaps into the store."
  },
  {
    "filepath": "\\guides\\intro\\get-started.md",
    "metadata": {
      "title": "Getting started",
      "table_of_contents": true
    },
    "heading": "# Getting started",
    "content": "Ubuntu Core is built from snaps, a secure, confined, dependency-free,\ncross-platform Linux packaging solution.\n\nIt's ideal for IoT and embedded systems because it manages itself.\nWhether it's running on a Raspberry Pi hidden for media streaming, or a\nQualcomm DragonBoard tucked away in a garage to handle automation, Ubuntu Core\nhandles application and security updates autonomously, \n\nSnaps are used by Ubuntu Core to both compose the image run on a device,\nand to deliver consistent and reliable software application updates, often to\nlow-powered, inaccessible, and remotely administered embedded and IoT systems.\n\nWhile Ubuntu Core can operate much like a traditional Ubuntu installation, its\ninstallation, management and deployment is directed by its snap foundations, as\noutlined below:\n\n\n|  |  |\n|--|--|\n| [1. Requirements](#heading--requirements) | [3. Installing Ubuntu Core](#heading--installing) |\n| [2. Choose a release](#heading--releases) | [4. Using Ubuntu Core](#heading--using) |\n\n----\n\n<h2 id='heading--requirements'>1. Requirements</h2>\n\nUbuntu Core runs on a large range of hardware, and pre-built images are\navailable for specific reference platforms. These images are a great way to\nquickly get started with Ubuntu Core on a Raspberry Pi, for example, or to\nexplore Ubuntu Core's features and evaluate its potential. See [Supported\nplatforms](../../platforms.md) for more details.\n\nAlongside enough storage to hold the Ubuntu Core image, installation also\nrequires a screen and keyboard to navigate a few installation prompts. These\naren't needed post-installation. \n\nAdditionally, you will need an [Ubuntu SSO account](https://login.ubuntu.com/),\nwith associated [SSH keys](https://login.ubuntu.com/ssh-keys). This setup is\nrequired because, after Ubuntu Core has been installed, Ubuntu SSO is used to\nmarshal local or remote logins to your device. This behaviour can be changed\nafter the first login. For help importing SSH keys, see the [Ubuntu community\nwiki](https://help.ubuntu.com/community/SSH/OpenSSH/Keys).\n\nWhen Ubuntu Core is up and running, if you want to access your device remotely,\nyou'll need an SSH client for your operating system. Linux and macOS both have\nclients built-in, whereas Windows users could use [Ubuntu on\nWSL](https://ubuntu.com/wsl).\n\n<h2 id='heading--releases'>2. Choose a release</h2>\n\nUbuntu Core releases track a corresponding [Ubuntu LTS\nrelease](https://ubuntu.com/about/release-cycle), and there are currently three\nsupported versions available:\n\n| **Ubuntu Core version** | **Ubuntu base** | **Status** |\n|--|--|--|\n| Ubuntu Core 20 (UC20) | [Ubuntu 20.04 LTS (Focal Fossa)](https://releases.ubuntu.com/20.04/) | [beta1](../../releases/uc20.md) |\n| Ubuntu Core 18 (UC18) | [Ubuntu 18.04 LTS (Bionic Beaver)](https://releases.ubuntu.com/18.04/) | supported |\n| Ubuntu Core 16 (UC16) | [Ubuntu 16.04 LTS (Xenial Xerus)](https://releases.ubuntu.com/16.04/)  | supported |\n\nUbuntu Core is more than a repackaged version of Ubuntu. Ubuntu Core 20, for\nexample, offers full-disk encryption, a new recovery mode and Raspberry Pi\nARMv7 and ARMv8 support.\n\nUbuntu Core 18 has the broadest hardware and compatibility support, and we\ncurrently recommend this for general use. Ubuntu Core 16 is useful for some\nlegacy systems.\n\n<h2 id='heading--installing'>3. Install Ubuntu Core</h2>\n\nThe typical installation procedure is as follows:\n\n1. **Download your preferred Ubuntu Core image for your device**</br>\n   See [Supported platforms](../../platforms.md) for links to images.</br>\n   By default, images are compressed with _xz_ and can be expanded with `xz -d <image-name.img.xz`.\n1. **Write the image to your device's storage medium** (eg. SD card for Raspberry Pi)</br>\n   We recommend using [Raspberry Pi imager](https://www.raspberrypi.org/downloads/) for Windows, macOS and Linux.\n1. **Boot the device from the flashed storage and follow the on-screen prompts**</br>\n   This step is version-specific, but the installation typically asks only two questions.\n\nFor example, when booting a fresh Ubuntu Core 18 image on a Raspberry Pi with a\nkeyboard and monitor connected, after pressing enter twice to navigate the\npreamble, you're first asked to configure a network connection.  Standard DHCP\nethernet connections are configured automatically, but for integrated Wifi, you\nneed to navigate to the `wlan0` device and press _Enter_ to access SSID and\nwifi settings. When complete, select _Done_ to complete the network\nconfiguration. \n\nThe final step for any Ubuntu Core installation is to enter the email address\nassociated with your SSO account. This is what provides the secure and\nautomatic authentication to your device, and subsequent reboots of your\nhardware will show host fingerprints alongside the SSH command required to\naccess your device. Use this to connect to your device:\n\n```bash\n$ ssh <your key> <SSO identity>@<device IP address>\n```"
  },
  {
    "filepath": "\\guides\\intro\\get-started.md",
    "metadata": {
      "title": "Getting started",
      "table_of_contents": true
    },
    "heading": "### Testing Ubuntu Core with QEmu",
    "content": "You can test Ubuntu Core without specific hardware from within a virtual\nmachine.\n\nTo test Ubuntu Core with QEMU ([https://www.qemu.org/](https://www.qemu.org)),\non Ubuntu, first install the `qemu-kvm` package and test it with _kvm-ok_:\n\n```bash\n$ sudo apt install qemu-kvm\n$ kvm-ok\n```\nTo ensure compatibility with the UEFI security features in Ubuntu Core 20, also\ninstall the [OVMF](https://wiki.ubuntu.com/UEFI/OVMF) package:\n\n```bash\nsudo apt install ovmf\n```\n\nThe exact command to run will depend on your host hardware capabilities, such\nas available memory and CPU cores, but the following should work in the\nmajority of cases:\n\n```bash\n$ qemu-system-x86_64 -enable-kvm -smp 2 -m 1500 \\\n -netdev user,id=mynet0,hostfwd=tcp::8022-:22,hostfwd=tcp::8090-:80 \\\n -device virtio-net-pci,netdev=mynet0  -drive file=pc.img,format=raw \\\n -drive file=/usr/share/OVMF/OVMF_CODE.fd,if=pflash,format=raw,unit=0,readonly=on\n```\n\nIn the above command, the Ubuntu Core image is called _uc.img_ and we forward\nthe virtual SSH port 22 to port 8022 on the host, and 80 to 8090 for any web\nserver you run. To access this configuration from your host machine, type the\nfollowing:\n\n```bash\n$ ssh <your key> <SSO identity>@<device IP address> -p 8022\n```\n\n<h2 id='heading--using'>4. Using Ubuntu Core</h2>\n\nIn use, the Ubuntu Core environment is much like a vanilla Ubuntu environment. The\nmain difference is that its system configuration, package management, and\nupdate control is all governed by _snapd_, the snap daemon.\n\nSnap features are comprehensively explained in the [Snap\ndocumentation](https://snapcraft.io/docs), but we'll cover some basic\noperations below:\n\nYou can list which snaps are installed with _snap list_:\n\n```bash\n$ snap list\nName       Version        Rev   Tracking     Publisher   Notes\ncore20     20             768   latest/beta  canonical✓  base\npc         20-0.4         108   20/beta      canonical✓  gadget\npc-kernel  5.4.0-47.51.1  598   20/beta      canonical✓  kernel\nsnapd      2.46.1         9279  latest/beta  canonical✓  snapd\n```\n\nThe above shows the standard set of snaps in a default Ubuntu Core 20\ninstallation. For more details on what these do, see [Snaps in Ubuntu\nCore](../../coresnaps.md).\n\nAs Ubuntu Core is a minimal installation, one of the first things you might\nwant to install is a text editor. You can search for snaps using _snap find_,\nor the [Snap Store](https://snapcraft.io/store). Nano is a good choice:\n\n```bash\n$ snap install nano\n```\n\nBy default, Ubuntu Core defaults to disabling access to most resources,\nincluding writing files to your home directory. Permissions in snap and Ubuntu\nCore are handled by _interfaces_. You can see which interfaces nano needs with\nthe _snap connections_ command:\n\n```bash\nsnap connections nano\nInterface        Plug                  Slot  Notes\nhome             nano:home             -     -\nremovable-media  nano:removable-media  -     -\n```\n\nConnecting the [home](https://snapcraft.io/docs/home-interface) interface\nbetween Ubuntu Core and _nano_ will allow you to save files to your home\ndirectory. This is accomplished with the _connect_ command:\n\n```bash\n$ snap connect nano:home :home\n$ snap connections nano\nInterface        Plug                  Slot   Notes\nhome             nano:home             :home  manual\nremovable-media  nano:removable-media  -      -\n```\n\nAfter running the above command, you will now be able use nano to create and\nedit text files in your home directory!\n\nThe `:home` syntax denotes the _home_ slot on Ubuntu Core. For more information\non how to work with interfaces, see [Interface\nmanagement](https://snapcraft.io/docs/interface-management) in the snap\ndocumentation.\n\nTo remove a snap from your system, along with its internal user, system and\nconfiguration data, use the remove command:\n\n```bash\n$ sudo snap remove nano\nnano removed\n```\n\nFor more information on how to work with snaps, including how to control\ndaemons/servers, how to make data snapshots and how to install specific\nrevisions, see the [Snap Documentation](https://snapcraft.io/docs/)."
  },
  {
    "filepath": "\\guides\\intro\\security.md",
    "metadata": {
      "title": "Security and sandboxing",
      "table_of_contents": true
    },
    "heading": "# Security and sandboxing (part 1)",
    "content": "Without custom flags at installation, snaps run confined within a restrictive security sandbox.\n\nThe security policies and store policies work together to allow developers to quickly update their applications and to provide safety to end users.\n\nThis document describes the sandbox and how to configure and work with the security policies for snaps.\n\n- [Security policy walkthrough](#heading--walkthrough)\n- [AppArmor, Seccomp and device permissions](#heading--permissions)\n- [Interface security policies](#heading--interface)\n\nFor help resolving issues that may arise from a snap’s security policy, see [Debugging snaps](https://snapcraft.io/docs/debug-snaps).\n\n<h2 id='heading--walkthrough'>Security policy walkthrough</h2>\n\nApplication developers should not need to know about, or understand, the low-level implementation details of how a security policy is enforced.\n\nEach command declared with the `apps` [snap metadata](https://snapcraft.io/docs/snap-format#heading--snapyaml) is tracked by the system assigning a security label to the command.\n\nThis security label takes the form of `snap.<snap>.<app>` where `<snap>` is the name of the snap, and `<app>` is the application name. \n\nFor example, the following is an app declaration from `snap.yaml`:\n\n```yaml\nname: foo\nversion: 1.0\napps:\n  bar:\n    command: bar\n  baz:\n    command: baz\n    daemon: simple\n    plugs: [network]\n```\n\n* the security label for  `bar`  is  `snap.foo.bar` . It uses only the default policy\n* the security label for  `baz`  is  `snap.foo.baz` . It uses the  `default`  policy plus the  `network`  interface security policy as provided by the core snap\n\nThis security label is used throughout the system, including during the process confinement phase when running the application.\n\nUnder the hood, the application runner does the following:\n\n1. Sets up various environment variables:\n    * `HOME`: set to `SNAP_USER_DATA` for all commands\n    * `SNAP`: read-only install directory\n    * `SNAP_ARCH`: the architecture of device (eg, amd64, arm64, armhf, i386, etc)\n    * `SNAP_DATA`: writable area for a particular revision of the snap\n    * `SNAP_COMMON`: writable area common across all revisions of the snap\n    * `SNAP_LIBRARY_PATH`: additional directories which should be added to `LD_LIBRARY_PATH`\n    * `SNAP_NAME`: snap name\n    * `SNAP_INSTANCE_NAME`: snap instance name incl. instance key if one is set (snapd 2.36+)\n    * `SNAP_INSTANCE_KEY`: instance key if any (snapd 2.36+)\n    * `SNAP_REVISION`: store revision of the snap\n    * `SNAP_USER_DATA`: per-user writable area for a particular revision of the snap\n    * `SNAP_USER_COMMON`: per-user writable area common across all revisions of the snap\n    * `SNAP_VERSION`: snap version (from `snap.yaml`)\n\n1. When hardware is assigned to the snap, a device cgroup is set up with default devices (eg, /dev/null, /dev/urandom, etc) and any devices that are assigned to this snap. Hardware is assigned with _interface_ connections.\n\n1. Sets up a private mount namespace shared across all the commands in the snap.\n\n1. Sets up a private `/tmp` directory using a per-snap private mount namespace and mounting a per-snap directory on /tmp.\n\n1. Sets up a new instance of _devpts_ per command.\n\n1. Sets up the seccomp filter for the command.\n\n1. Executes the command under the command-specific AppArmor profile under a default nice value.\n\n<h2 id='heading--permissions'>AppArmor, Seccomp and device permissions</h2>\n\nWhen a snap is installed, it's metadata is examined and used to derive **AppArmor** profiles, **Seccomp** filters and device **cgroup** rules, alongside **traditional permissions**. This combination provides strong application confinement and isolation:\n\n- <h3 id='heading--apparmor'>AppArmor</h3>\n\n   AppArmor profiles are generated for each command. These have the appropriate security label and command-specific AppArmor rules to mediate file access, application execution, Linux capabilities, mount, ptrace, IPC, signals, coarse-grained networking.\n\n   As already mentioned, each command runs under an app-specific default policy that may be extended through declared interfaces which are expressed in the metadata as `plugs` and `slots`. AppArmor policy violations in strict mode snaps will be denied access, and typically have errno set to `EACCES`. The violation will be logged..\n\n- <h3 id='heading--seccomp'>Seccomp</h3>\n\n   A seccomp filter is generated for each command in a snap to run under, enabling whitelist syscall filtering, which can then be extended through declared interfaces expressed in the metadata as `plugs` and `slots`.\n   \n   Processes with seccomp policy violations will be denied access to the system call with errno set to `EPERM` (snapd releases prior to 2.32 receive `SIGSYS`) and the violation is logged.\n\n- <h3 id='heading--cgroup'>Device cgroup</h3>\n\n    udev rules are generated for each command to tag devices so they may be added/removed to the command's device cgroup. By default, however, no devices are tagg"
  },
  {
    "filepath": "\\guides\\intro\\security.md",
    "metadata": {
      "title": "Security and sandboxing",
      "table_of_contents": true
    },
    "heading": "# Security and sandboxing (part 2)",
    "content": "ed and the device cgroup is not used, with AppArmor used to mediate access.\n    \n    A device cgroup may be used in addition to AppArmor when a dependent interface is declared, as expressed through `plugs` and `slots` in the metadata.\n    \n    Processes accessing devices not in the snap-specific device cgroup will be denied access with errno set to `EPERM`. Access violations are typically not logged.\n\n- <h3 id='heading--permissions'>Traditional permissions</h3>\n\n    Traditional file permissions (owner, group, file ACLs and others) are also enforced with snaps.\n    \n    Processes trying to access resources which the traditional file permissions do not allow are denied access with errno typically set to `EACCES` (see the man page for the operation for specifics). Access violations are typically not logged.\n\nConsequently, all snaps run under a default security policy which can be extended through the use of [interfaces](https://snapcraft.io/docs/snapcraft-interfaces). \n\n<h3 id='heading--interface'>Interface security policies</h3>\n\nInterfaces are implemented as plugs and slots. A plug in one snap may connect to a slot in another and this provides access to the resources required.\n\nThe _snap connections_ command can be used to see available interfaces alongside their slots and plugs.\n\n```bash\n$ snap connections\nInterface           Plug                                Slot               Notes\nhome                wormhole:home                       :home              -\nlog-observe         gnome-logs:log-observe              :log-observe       -\nmount-observe       gnome-system-monitor:mount-observe  :mount-observe     -\n[...]\n```\n\nIn the above example output, the  `gnome-logs`  snap is connected to the `log-observe`  interface, which means the security policy from  `log-observe`  has been added to `gnome-logs`.\n\nInterfaces can be declared either per-snap or per-command:\n- if declared per-snap, all the commands within the snap have the interface security policy added to the command’s security policy when the interface is connected\n- if declared per-command, only the commands within the snap that declare use of the interface have the interface security policy added to them\n\nAn interface may either auto-connect upon install, or require the user to manually connect them. Interface connections and disconnections are performed via the  `snap connect`  and  `snap disconnect` commands. See [interfaces](https://snapcraft.io/docs/interface-management) for details."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "# Store and developer accounts",
    "content": "Snaps and Ubuntu core devices in general are tied to accounts existing in the Ubuntu store or in another snaps enabled store."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## The Ubuntu Store",
    "content": "The main way of distributing snaps to is through [the Ubuntu Store](https://dashboard.snapcraft.io \"Ubuntu store\"), where you can customize how your snap is presented, review each new upload, and control publishing over several release channels. Here is the model it follows."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## Developer namespace",
    "content": "You'll choose a unique developer namespace as part of the store account creation process. This namespace will represent you as a publisher in the store and you won't be able to change it afterwards."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## Naming",
    "content": "You can publish a snap under any name you have rights to. Names can be registered by using the `snapcraft register` command, clicking **New Snap** on the developer portal, or by visiting the [Register name](https://dashboard.snapcraft.io/dev/snaps/register-name/ \"register name\") page. You can also grant other developers permission to publish versions of a snap you own, for example as part of an open source project."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## Collaborating",
    "content": "You can share the management of any snap registered in the store under your own namespace. This will allow you to collaborate on specific snaps and extend administration rights (upload and publication) to other developers."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## Uploading",
    "content": "Uploading snaps to the store can be done directly from the command line or on the [store website](https://dashboard.snapcraft.io \"Ubuntu store\") itself. Once uploaded you choose the release channel(s) (`stable`, `candidate`, `beta`, `edge`) that the snap will be published to.\n\nIt's worth noting that when you upload a snap, the store assigns it a revision number of 1\\. The store then automatically increments this revision number each time you upload a new version."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## Release channels",
    "content": "On the store, snaps can be published into different channels: `stable`, `candidate`, `beta`, and `edge`. This enables you to engage with users who are willing to test changes, and it helps users decide how close to the leading edge of development they want to be.\n\nThere are four channels available and snaps can be published into several at the same time:\n\n* `stable` is what most users will consume and as the name suggests, should be your most polished, stable and tested versions. Snaps in this channel appear in user searches.\n* `candidate` is used to vet uploads that should require no further code changes before moving to stable.\n* `beta` is used to provide preview releases of semi-stable changes. Snaps requiring the devmode flag to work are allowed in this channel.\n* `edge` is for your most recent changes, probably untested and with no guarantees attached. Snaps requiring the devmode flag to work are allowed in this channel.\n\nBy default, snaps are installed from the `stable` channel. Versions of snaps from other channels need to be explicitly selected by users:\n\n    snap install hello --beta\n\nAnd snaps can be refreshed from a different channel to the one it was originally installed from:\n\n    snap install hello\n    snap refresh hello --beta\n\nThis switches the snap to using the `beta` channel for future updates."
  },
  {
    "filepath": "\\guides\\intro\\store.md",
    "metadata": {
      "title": "Stores and developer accounts",
      "table_of_contents": true
    },
    "heading": "## Publishing",
    "content": "After you've chosen a channel, your snap is sent for review. Most snaps are reviewed by way of automated checks, but if your snap uses sensitive [interfaces](../../reference/interfaces/index.html), it may be flagged for a manual review and you will receive a notification email from the store whenever the status of the review evolves.\n\nOnce your snap has been reviewed and approved, you can publish it when you're ready, instantly making the snap available to users."
  },
  {
    "filepath": "\\guides\\intro\\what-is-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "# What is Ubuntu Core?",
    "content": "<!-- \nVersion: 2.0\n-->\n\nUbuntu Core is Ubuntu for IoT and embedded environments, optimised for security and\nreliable updates. It's easy to deploy, tamper-resistant, and hardened against\ncorruption.\n\nIts read-only root filesystem is built from the same packages used to build the\nwider set of Ubuntu distributions, and only differs in the way packages are\ndelivered, and crucially, updated. This is all handled by snaps, a secure,\nconfined, dependency-free, cross-platform Linux packaging system.\n\nSnap packages ensure there is always a clean separation between the base system\nand whatever applications need to be installed, as well as isolation between\neach and every application, their data, and even application version data.\n\nUpdates are transactional, which means they’re either 100% successful or\nthey’re not installed. If they're not installed, they leave no trace of any\nfailure other than log details. This means the system remains fully operational\nand in a continuously well-defined state during both application and system\nupdates. The system can also recover or revert to previous states if necessary, \neven if a system fails to boot. Unlike alternative or more traditional\npackage managers, a failed update never leaves the system in an unpredictable\nstate."
  },
  {
    "filepath": "\\guides\\intro\\what-is-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "### Advantages for IoT",
    "content": "Ubuntu Core is engineered to meet the precise requirements of IoT devices. It\nruns on a large range of hardware, including Raspberry Pi, Intel NUC, Qualcomm\nSnapdragon 410c and even a KVM. Features include:\n\n- **simple, consistent installation and deployment**: Ubuntu Core is installed\n  via an immutable image, which can be either installed or built specifically\n  for your platform and application\n- **a read-only filesystem**: apps run in isolation from each other and access\n  to system resources is only granted with explicit permissions\n- **transactional updates**: signed, autonomous and atomic, updates can withstand\n  unpredictable hardware and network conditions, even to the operating system\n- **snap-based, security first**: snaps are secure, easy to build, and painless\n  to distribute. Public/private key validation ensures what's running is\nexactly what's intended to run\n\nDesigned from the ground-up to solve the complex problems associated with\ndeploying, running and updating critical software, **Ubuntu Core** makes updates\nautomatic, reliable, secure and transparent whilst still offering a broad and\ncarefully selected level of control and customisation over an update’s\ndeployment."
  },
  {
    "filepath": "\\guides\\intro\\what-is-core.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "#### Ubuntu Core and Ubuntu",
    "content": "The Ubuntu family of Linux distributions includes Ubuntu Desktop and Ubuntu\nServer, as well as Ubuntu Cloud which is optimised and certified for most major\nclouds. Ubuntu Core is built from the same foundations but differs in the way\nthose foundations are packaged and deployed.\n\n| **Comparison** | Ubuntu Core | Ubuntu |\n|--|--|--|\n| Minimum requirements | 500Mhz single-core CPU <br /> 384MB RAM, 512MB storage | 1GHz dual-core CPU <br /> 512MB RAM, 1.5GB storage | \n| Packaging       | Snaps, with autonomous updates via either the global store or a private brand store | Debs and snaps, with traditional update mechanics and organisation |\n| App security         | Confinement via AppArmor / Seccomp | No system-wide confinement for deb packages |\n| Graphical UI         | None by default (Wayland or Mir are options)\t| X.Org/GNOME or Wayland/GNOME |"
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "# System user",
    "content": "On some systems it is appropriate to have a system user. For example, with a system user, one can SSH to the device and run commands.\n\nBy default on first boot, stock Core images run a program called console-conf. If you have a keyboard and monitor attached to the device or have a serial connection, you can use console-conf to configure the network and add a user account. The user account is created based on your registered email address and SSH key. This user account can then be used to SSH to the device for various management purposes. (Technically, this is not a system user account because it is not created through assertion, but the end result is equivalent.)\n\nSome systems suppress console-conf, and a user is not created by default. In these cases, one may add a system user if one has the information and authority needed to do so for a particular system. This is done by inserting a USB drive with a special file (named `auto-import.assert`) in the root directory. Snapd imports the assertions found in it, and, if the assertions are valid for the given system, the system user is created. After this, you can log into the device (locally or over SSH) using the username and password defined.\n\nIn general, you cannot add a system user to a system that is already \"managed\". A system is managed if a user was already created by console-conf, or if a system user was created through the auto-import mechanism described here.\n\nWhether you can add a system user to an unmanaged system depends on the model assertion that was used to create the image. It also depends on whether you have an authorized snapcraft key on your local system. For a discussion of keys, see [Ubuntu Core Images](../build-device/image-building.md)."
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "## Model assertions that allow adding a system user",
    "content": "The model includes store account IDs. To find yours, look for the `Snap account-id` field on the account details page at [https://dashboard.snapcraft.io](https://dashboard.snapcraft.io/dev/account/)."
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "### The simplest case is where you did everything:",
    "content": "* You created a snapcraft key and you have registered it with `snapcraft register-key KEY`\n* You created a model assertion\n* The model assertion has the `authority-id` set to your account ID\n* The model assertion has the `brand-id` set to your account ID\n* You signed the model assertion using the key mentioned above\n* You built the image using that model assertion\n\nThe model assertion (original JSON) may look like this:\n\n```\n{\n  \"type\": \"model\",\n  \"authority-id\": \"ACCOUNT-ID\",\n  \"brand-id\": \"ACCOUNT-ID\",\n  \"series\": \"16\",\n  \"model\": \"mymodel\",\n  \"architecture\": \"armhf\",\n  \"kernel\": \"pi2-kernel\",\n  \"gadget\": \"cm3\",\n  \"timestamp\": \"2017-07-11T15:55:59+00:00\"\n}\n```\n\nNote that this model assertion does not have a `system-user-authority` field. When a model assertion lacks this key, a system user assertion can only be signed by a key registered to the store account specified by the `brand-id` field. But, in this case, you do have the key needed to sign the system user assertion."
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "### Specifying other accounts that can sign the system user assertion",
    "content": "You can use the optional `system-user-authority` field to list a set of account IDs that are authorized to sign system user assertions for any image built with this model assertion.\n\n```\n{\n  \"type\": \"model\",\n  \"authority-id\": \"ACCOUNT-ID\",\n  \"brand-id\": \"ACCOUNT-ID\",\n  \"system-user-authority\": [\n    \"ANOTHER-ACCOUNT-ID\",\n    \"YET-ANOTHER-ACCOUNT_ID\"\n  ],\n  \"series\": \"16\",\n  \"model\": \"mymodel\",\n  \"architecture\": \"armhf\",\n  \"kernel\": \"pi2-kernel\",\n  \"gadget\": \"cm3\",\n  \"timestamp\": \"2017-07-11T15:55:59+00:00\"\n}\n```\n\nIn this case, any one who can log in to either ANOTHER-ACCOUNT-ID or YET-ANOTHER-ACCOUNT_ID accounts can sign system user assertions with keys registered to those accounts. And such system user assertions are valid for systems built with this model."
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "### Self-signed system user assertions",
    "content": "A model can also specify that anyone with a registered key can create a valid system user assertion. This is done with an asterisk (\"*\") in the `system user-authority` field:\n\n```\n{\n  \"type\": \"model\",\n  \"authority-id\": \"ACCOUNT-ID\",\n  \"brand-id\": \"ACCOUNT-ID\",\n  \"system-user-authority\": \"*\",\n  \"series\": \"16\",\n  \"model\": \"mymodel\",\n  \"architecture\": \"armhf\",\n  \"kernel\": \"pi2-kernel\",\n  \"gadget\": \"cm3\",\n  \"timestamp\": \"2017-07-11T15:55:59+00:00\"\n}\n```"
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "## Creating a system user assertion",
    "content": "We now know that creating a valid system user assertion is limited by the model assertion. And, there is information in the model assertion that is needed to create the system user assertion, specifically the `brand-id` and the `model`.\n\n\nThere's a snap that makes this part easy: make-system user. This can be installed on a classic Ubuntu system or a Core system using the classic snap.\n\n1. Install it \n\n        snap install make-system-user --classic\n\n1. Check its help:\n\n        make-system-user.run --help\n\n    The help specifies that you need the brand, which is the `brand-id` field's value in the model assertion. \n\n    You also need the value of the `model` field, in this case: `mymodel`\n\n    You need to specify a username and password. \n\n    And, you need to name the key to sign the assertion. Note that the assertion only works on a given system if the key is within the limitations of the model assertion as described previously.\n\n\n1. Here is a sample execution matching the above:\n\n```bash\nsudo make-system-user.run --brand ACCOUNT-ID --model mymodel --username chuckthecoolcat --password heresapassword --key MYVALIDKEY\n```\nWhich should generate output similar to:\n\n```no-highlight\nYou need a passphrase to unlock the secret key for\nuser: \"MYVALIDKEY\"\n4096-bit RSA key, ID C375E301, created 2016-01-01\n\nDone. You may copy auto-import.assert to a USB drive and insert it into an unmanaged Core system, after which you can log in using the username and password you provided.\n```\n\nThe result is `auto-import.assert` in your current directory. This can be used on an qualifying image (described above) that is not already *managed* to make a system user. \n\nSimply copy `auto-import.assert` to the root directory of a USB drive, insert it, and the system user is created. \n\n**Tip**: If you are creating the system user on the first boot, it may take some minutes for the assertion to be imported and for the system user to be created."
  },
  {
    "filepath": "\\guides\\manage-devices\\index.md",
    "metadata": {
      "title": "System user",
      "table_of_contents": true
    },
    "heading": "## Checking if a system user assertion was created",
    "content": "If you can log in with the username and password, the system user has been created. \n\nYou can also use the `snap known system-user` command. If there is a system user, the signed assertion is output."
  },
  {
    "filepath": "\\image\\custom-images.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "# Custom images",
    "content": "Building a bespoke image for a [Supported platform](../platforms.md) enables an\nUbuntu Core device to be customised at the point of deployment.  Customisation\noptions include configuration for both hardware and software, specific kernels,\nand which snap packages to pre-install.\n\nSee [Image building](image-building.md) for an overview of building reference\nUbuntu Core images for a supported platform.\n\n<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\"><span class=\"p-notification__status\">Note:</span>\nBuilding for non-reference architectures is also easily accomplished but\nrequires upstream enablement. For further details, <a\nhref=\"https://ubuntu.com/core#get-in-touch\">contact Canonical.</a> </p></div>"
  },
  {
    "filepath": "\\image\\custom-images.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Prerequisites",
    "content": "To build a custom image, first use the _snapcraft_ command to login to the [Snap\nStore](https://snapcraft.io/store):\n\n```bash\n$ snapcraft login\n```\n\nSnapcraft can be installed with `sudo snap install snapcraft --classic`, see\n[Snapcraft overview](https://snapcraft.io/docs/snapcraft-overview) for further\ndetails, and visit [Create a developer\naccount](https://snapcraft.io/docs/creating-your-developer-account) if you\ndon't yet have an account.\n\nBefore creating a custom model assertion, you will need to retrieve your\ndeveloper ID and generate a properly formatted timestamp. The _snapcraft_\ncommand can be used to retrieve your developer id:\n\n```bash\n$ snapcraft whoami\nemail: <email>\ndeveloper-id: bJzr2XzZ56Qv6Z51HIeziXvxtn1XItIq\n```\n\nUse the following _date_ command to output the correctly formatted timestamp\nfor the model assertion:\n\n```bash\n$ date -Iseconds --utc\n2020-03-10T12:34:57+00:00\n```"
  },
  {
    "filepath": "\\image\\custom-images.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Custom model assertion",
    "content": "The following is a tweaked JSON-structured custom model assertion based on\n[ubuntu-core-18-amd64](http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-amd64.model-assertion):\n\n```json\n{\n  \"type\": \"model\",\n  \"series\": \"16\",\n  \"model\": \"ubuntu-core-18-amd64\",\n  \"display-name\":\"Ubuntu Core 18 (amd64)\",\n  \"architecture\": \"amd64\",\n  \"kernel\": \"pc-kernel=18\",\n  \"gadget\": \"pc=18\",\n  \"base\": \"core18\",\n  \"required-snaps\": [\"hello\", \"hello-world\"],\n  \"authority-id\": \"bJzr2XzZ56Qv6Z51HIeziXvxtn1XItIq\",\n  \"brand-id\": \"bJzr2XzZ56Qv6Z51HIeziXvxtn1XItIq\",\n  \"timestamp\": \"2020-03-10T12:05:38+00:00\"\n}\n```\n\nWe've saved the above example in a file called `my-model.json`, and it contains\nthe following modified properties:\n\n- `base`: provides the run-time environment  \n  _core18_ is the current standard base and as is built from [Ubuntu 18.04 LTS](http://releases.ubuntu.com/18.04/). See [Base snaps](https://forum.snapcraft.io/t/base-snaps/11198) for more details.\n- `authority-id`, `brand-id`: defines the authority signing the assertion  \n  reference assertions are signed by `canonical`. Non-reference assertions are\nsigned by their [brand store](build-store/index.md). For a custom model\nassertion, this needs to be the developer ID.\n- `timestamp`: UTC formatted time and date  \n  used to denote the assertion's creation time.\n- `required-snaps`: one or more snaps to be pre-installed for deployment\n  any snap can be listed here. If there's a dependency on a different base, such as _core_, this will be installed too.  \n\nFor a complete list of model assertion keywords, see [Model assertion](../reference/assertions/model.md)."
  },
  {
    "filepath": "\\image\\custom-images.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Signing a model assertion",
    "content": "The difference between building an image from a reference model assertion and\nbuilding from a modified model assertion is that the modified model assertion\nneeds to be digitally signed. This is accomplished in four stages:\n\n1. create a key\n1. export/register the key\n1. sign the model assertion\n1. build the image\n\n<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\"><span class=\"p-notification__status\">Note:</span>\nRather than creating a key for every device, the same key is typically used across all models or model family.\n</p></div>\n\nFirst, sign in to the [Snap Store](https://snapcraft.io/store) (_snap login_)\nand check whether there is already a published key available. You can list any\npublished snaps with the _snap keys_ command:\n\n```bash\n$ snap login\n[...]\nLogin successful\n\n$ snap keys\nNo keys registered, see `snapcraft create-key`\n```\n\nIf you have no registered keys, create one as follows:\n\n```bash\n$ snap create-key my-models\nPassphrase:\nConfirm passphrase: <passphrase>\n\n$ snap keys\nName         SHA3-384\nmy-key-name  E-n0AOKPFjIyy4S_i9JxTT4tkuaZf7rP9D2ARCmBNXjlgTGDjL8euFSlb87U0NPl\n```\n\nWith a key created, use the _snapcraft_ command to upload and register it with\nthe store:\n\n```bash\n$ snapcraft register-key\nRegistering key ...\n```\n\nA custom model assertion is signed by piping the assertion through the _snap\nsign_ command with the key name as its sole argument:\n\n```bash\n$ cat my-model.json | snap sign -k my-key-name > my-model.model\n```\n\nThe resulting `my-model.model` file contains the signed model assertion and can\nnow be used to build the image."
  },
  {
    "filepath": "\\image\\custom-images.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Building the image",
    "content": "With a [signed model assertion](#signing-a-model-assertion), the Ubuntu Core\nimage can now be built just like a reference image, using the\n[ubuntu-image](image-building.md#building-with-ubuntu-image) command:\n\n```bash\n$ ubuntu-image snap my-model.model\nFetching snapd\nFetching pc-kernel\nFetching core18\nFetching pc\nFetching hello\nFetching hello-world\nFetching core\nWARNING: model has base \"core18\" but some snaps (\"hello\", \"hello-world\") require \"core\" as base as well, for compatibility it was added implicitly, adding \"core\" explicitly is recommended\n```\n\nAs with when building a reference image, you can now use the image to boot either\nreal or virtual hardware. See [Building the\nimage](image-building.md#building-with-ubuntu-image) for more details.\n\n\nFrom within a running session on a custom image, you can run the pre-installed\nsnaps:\n\n```bash\n$ hello-world\nHello World!\n```\n\nUse _snap list_ to see which snaps are installed:\n\n\n```bash\n$ snap list\nName         Version       Rev   Tracking  Publisher   Notes\ncore         16-2.43.3     8689  stable    canonical✓  core\ncore18       20200124      1668  stable    canonical✓  base\nhello        2.10          38    stable    canonical✓  -\nhello-world  6.4           29    stable    canonical✓  -\npc           18-2          36    18        canonical✓  gadget\npc-kernel    4.15.0-88.88  399   18        canonical✓  kernel\nsnapd        2.43.3        6434  stable    canonical✓  snapd\n```\n\nThe _snap known model_ command will show the read-only custom model\nassertion used to build the image:\n\n```bash\n$ snap known model\ntype: model\nauthority-id: bJzr2XzZ56Qv6Z51HIeziXvxtn1XItIq\nseries: 16\nbrand-id: bJzr2XzZ56Qv6Z51HIeziXvxtn1XItIq \nmodel: ubuntu-core-18-amd64\narchitecture: amd64\nbase: core18\ndisplay-name: Ubuntu Core 18 (amd64)\ngadget: pc=18\nkernel: pc-kernel=18\nrequired-snaps:\n  - hello\n  - hello-world\ntimestamp: 2020-03-10T12:05:38+00:00\nsign-key-sha3-384: 9aZR3b1UX9kqiVVxzfUrKYzYjHX-gC8jGNc4hTCpGfpPyaFdWR7K68HLoY1EH3yR\n[...]\n```"
  },
  {
    "filepath": "\\image\\image-building.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "# Image building",
    "content": "Any device running Ubuntu Core is instantiated from an image. This image\ncontains little more than the kernel, an _init_ process, and a few essential\ntools. On all but the earliest releases of Ubuntu Core, even the _snapd_ daemon\nthat manages snaps is itself installed via its own snap.\n\nReference images are available for supported platforms, including Raspberry Pi,\nQualcomm Snapdragon and x86/KVM virtualisation, and these can be download and\ninstalled easily. See [Supported platforms](../platforms.md) for the current list\nand for download links to both the images and the model assertions they use."
  },
  {
    "filepath": "\\image\\image-building.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Inside a model assertion",
    "content": "Creating an Ubuntu Core image starts with a _model assertion_, a digitally\nsigned text file with structured headers defining every aspect of the image.\nThe input for defining and signing such a document is provided as JSON text:\n\n```json\n{\n  \"type\": \"model\",\n  \"series\": \"16\",\n  \"model\": \"ubuntu-core-18-pi-arm64\",\n  \"architecture\": \"arm64\",\n  \"gadget\": \"pi=18-pi\",\n  \"kernel\": \"pi-kernel=18-pi\",\n  \"authority-id\": \"canonical\",\n  \"brand-id\": \"canonical\",\n  \"timestamp\": \"2020-01-22T08:35:30+00:00\"\n}\n```\n\nThe above snippet shows the reference [model assertion for the Raspberry\nPi](http://cdimage.ubuntu.com/ubuntu-core/18/stable/current/ubuntu-core-18-arm64+raspi.model-assertion).\nIt includes details such as the store to use (`brand-id` and `authority-id`),\nthe model name (`ubuntu-core-18-pi-arm64`) and the hardware architecture\n(`arm64`). Any snaps installed on the device will respect this selected\narchitecture.\n\nAs outlined in [Snaps in Ubuntu Core](../coresnaps.md), there are three principle\nsnaps-types that combine to create the Ubuntu Core environment. These are\n**kernel**, **gadget** and **core**, and all three need to be referenced within\na custom model assertion."
  },
  {
    "filepath": "\\image\\image-building.md",
    "metadata": {
      "title": "Ubuntu IoT Developer Documentation"
    },
    "heading": "## Building with ubuntu-image",
    "content": "Images are built from a model assertion using\n[ubuntu-image](https://github.com/CanonicalLtd/ubuntu-image), a tool to\ngenerate a bootable image. It can be installed on a [snap-supporting Linux\nsystem](https://snapcraft.io/docs/installing-snapd) as follows:\n\n```bash\n$ sudo snap install ubuntu-image --beta --classic\n```\n\nThe _ubuntu-image_ command needs only the filename of the model assertion to build an\nimage. \n\nThe following will build an _amd64_ image using the\n[ubuntu-core-18-amd64.model](https://raw.githubusercontent.com/snapcore/models/master/ubuntu-core-18-amd64.model)\nreference model assertion:\n\n\n```bash\n$ ubuntu-image snap ubuntu-core-18-amd64.model\nfetching snapd\nfetching pc-kernel\nfetching core18\nfetching pc\n```\n\nThe output includes the _img_ file itself, alongside _seed.manifest_ and\n_snaps.manifest_ files. These manifest files simply list the specific revision\nnumbers for the snapd, pc, pc-kernel and core snaps built within the image.\n\nYou can now test the resulting image. Using [QEMU](https://www.qemu.org/), for\ninstance, the following command will boot the image inside a VM and forward\n(SSH) port 22 to 8022 on your machine: \n\n```bash\n$ qemu-system-x86_64 -enable-kvm -smp 2 -m 1500 \\\n-netdev user,id=mynet0,hostfwd=tcp::8022-:22,hostfwd=tcp::8090-:80 \\\n-device virtio-net-pci,netdev=mynet0 -drive file=pc.img,format=raw\n```\n\nAfter running through the Ubuntu Core network setup and entering your account\ndetails, you will be able to SSH to your new Ubuntu Core deployment:\n\n```bash\n$ ssh <username>@localhost -p 8022\n```\n\nYou are now connected to the Ubuntu Core virtual machine, from where you can\nconfigure and install whatever apps you need. \n\nTo list which snaps are installed, for example, type 'snap list':\n\n```bash\n$ snap list\nName       Version       Rev   Tracking  Publisher   Notes\ncore18     20200124      1668  stable    canonical✓  base\npc         18-2          36    18        canonical✓  gadget\npc-kernel  4.15.0-88.88  399   18        canonical✓  kernel\nsnapd      2.43.3        6434  stable    canonical✓  snapd\n```\n\nTo view the model assertion used to build the image, type `snap model\n--assertion`:\n\n```bash\n$ snap known model\ntype: model\nauthority-id: canonical\nseries: 16\nbrand-id: canonical\nmodel: ubuntu-core-18-amd64\narchitecture: amd64\nbase: core18\ndisplay-name: Ubuntu Core 18 (amd64)\ngadget: pc=18\nkernel: pc-kernel=18\ntimestamp: 2018-08-13T09:00:00+00:00\nsign-key-sha3-384: 9tydnLa6MTJ-jaQTFUXEwHl1yRx7ZS4K5cyFDhYDcPzhS7uyEkDxdUjg9g08BtNn\n[...]\n```\n\nTo output the serial assertion rather than the model assertion, type `snap\nmodel --serial`:\n\n```bash\n$ snap model --serial\nbrand-id:  canonical\nmodel:     ubuntu-core-18-amd64\nserial:    acb9cfdc-c4a1-4317-809e-e9c306cfc7e5\n```\n\nSee the [Snap documentation](https://snapcraft.io/docs) for more details on\nworking with snaps. To build a custom image that includes your own selection of\nsnaps, take a look at [Custom images](custom-images.md)."
  },
  {
    "filepath": "\\reference\\assertions.md",
    "metadata": {
      "title": "Assertions",
      "table_of_contents": true
    },
    "heading": "# Assertions (part 1)",
    "content": "Assertions are digitally signed documents that express a fact or policy by a\nparticular authority about a particular object in the snap universe. An\nassertion consists of a set of structured headers, which vary based on the\ntype of assertion, an optional body (UTF8 text, with format depending on type\nof assertion) and the signature.\n\nAssertions are intended to be understandable by human inspection, although\nfull validation requires the use of provided tooling.\n\nAssertions are the way trust information is transmitted between the different\nparts of the snap ecosystem (snapd daemon, snapcraft tool, store...).\nThey are used for things like stating who is the publisher of a snap or who\ncreated a device image, or for allowing to do some actions if the right\nassertion is provided (like creating a system user).\n\nThe typical format of an assertion, with common headers, is as follows:\n\n```text\ntype:          <type>       # For example, “account” or “model”\nauthority-id:  <account id> # On whose authority this assertion is made\nrevision:      <int>        # Assertions can be updated with a higher revision\n<key field 1>: <value>      # Fields identifying the object of the assertion\n...\n<key field N>: <value>\n<other field>: <value>\n...\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<body>                      # Optional type-dependent body\n\n<signature>                 # Encoded signature\n```\n\nEvery assertion will have a `type` and `sign-key-sha3-384`, as well as a\nsignature, and most will have an `authority-id`. Values may be scalars\n(strings, integers, booleans), lists, or maps. Some of the headers play\nthe role of an index, which uniquely specifies the context of this\nassertion given the type. Most assertions will also have a revision which\nenables a particular assertion to be updated by issuing another assertion\nof the same type and index with a higher revision. Given a particular type\nand index, there is only one “latest” valid assertion that properly\ndetermines policy for a system - the one with the highest revision. For a\ngiven assertion the index headers must all be defined.\n\nSome headers contain identifiers of one type or another. These ids are formed by\na sequence of 32 random characters taken out of an alphabet of 62 characters\n(uppercase letters + lowercase letters + numbers). However, in some cases the\nidentifier is a fixed name like \"canonical\". This only happens in special cases.\n\nWhen headers are defined as UTC date/time, the format that is needed is the\nsame as the one generated by the command.\n\n```bash\ndate -Iseconds --utc\n```\n\nIt can be instructive to learn about the assertions that are stored in a system.\nYou can find out with the command\n\n```bash\nsnap known <assertion type>\n```\n\nAdditionally, you can download the assertions associated to snaps in the store\nwith the command\n\n```bash\nsnap download <snap name>\n```\n\nwhich will download the snap and a file with its assertions. The file will\ncontain account-key of the snap owner, snap-declaration, and snap-revision\nassertions.\n\nAlthough in most cases assertions are generated automatically by the different\nparts of the system, it is worth noting that they can be generated manually\nwith the `snap sign` command. The input must have a JSON format, for instance\n\n```\n{\n    \"type\": \"account\",\n    \"authority-id\": \"234njDFJHG0jkh0asdAGQ43SESwerrfg\",\n    \"revision\": \"14\",\n    \"account-id\": \"asdfv389h4SSEDB49hasdfh8hfajhfak\",\n    \"display-name\": \"John Smith\",\n    \"username\": \"jsmith\",\n    \"validation\": \"unproven\",\n    \"timestamp\": \"2017-02-20T10:23:51+00:00\"\n}\n```\ncan be signed by doing\n\n```bash\ncat account.json | snap sign > account\n```\n(we would be signing with our default key).\n\nThe output would be similar to:\n```no-highlight\ntype: account\nauthority-id: 234njDFJHG0jkh0asdAGQ43SESwerrfg\nrevision: 14\naccount-id: asdfv389h4SSEDB49hasdfh8hfajhfak\ndisplay-name: John Smith\ntimestamp: 2017-02-20T10:23:51+00:00\nusername: jsmith\nvalidation: unproven\nsign-key-sha3-384: Ix2EqDXjEdsY8yZACzvpc-3J1C022LPnHTP29fdpaWfOuTr8dG6Bva2qlm3ftn9b\n\nAcLBXAQAAQoABgUCWKwrggAKCRAr48PRDeXDupqkEACnHhKv0DLqApeyzsr6sImgMfZ3+j7pxUz3\n7NWk/0Ld/RzimlOavKitxi3wHPfb2Tw6kTI/faO3s+E3+Uq4/luzLILZ5CAOczqQAuPgAdphlHMx\ngJCdFrOlw9quF4MtWJpXNa05OJsDm2G+B3GehJzReQ6vXriNjqTe/OmLrSpMPp7NoZb3nGcrNwWo\nKULfveCgNRwl61vU3EfHif8qo1rlX0l4mxOp5w9GDhuZQZ8l+bJW9vBpGXmnEDYfsdbO2gCNykbV\nCM+nkza/QdoAaBOiz2E/PFyipamRpv0ATo/RSePKTp9iUbOl1xNOiJBwc5+pUb6s3sDyzFNWIDBK\nmN2J7tu2pO3yYTqR/DQs8eY+MkqGnBEK8KuKzfe87Nszrrd+ulBliYepkmk3xfrhJGLHN1qebZ2K\n9ykYR8m2uoE5c2r40toaf6tay0QlddZq9aq6FvdnnA6CArbsdwbXZuMv780MmwnIFJk2D4p0+5mM\nSbSU63kiSJ+oQRKmHZ7jryP06kvzfYmSwT7LXjvu0qLx7ac+OoMiCyFzXcwGfvM9KzZW71fMTfvI\nfmuDl+fSm0edz1QURcamr4WmwlNI+yebPfrhZAWXvvfk/sXT2N12ojxp4M3DnO+1WVFHKaWyeS0G\neoyPdPAWyOm5KcTm3O92Q/jo3TQF5tyDMIHHOLnkUQ==\n```\n\nBelow we define in detail the currently supported assertions. Unless otherwise noted, all\nfields are madatory.\n\n* [account assertion](assertions/account.md)\n* [account-key assertion](assertions/account"
  },
  {
    "filepath": "\\reference\\assertions.md",
    "metadata": {
      "title": "Assertions",
      "table_of_contents": true
    },
    "heading": "# Assertions (part 2)",
    "content": "-key.md)\n* [model assertion](assertions/model.md)\n* [serial assertion](assertions/serial.md)\n* [snap-declaration assertion](assertions/snap-declaration.md)\n* [snap-build assertion](assertions/snap-build.md)\n* [snap-revision assertion](assertions/snap-revision.md)\n* [system-user assertion](assertions/system-user.md)\n* [validation assertion](assertions/validation.md)"
  },
  {
    "filepath": "\\reference\\automatic-refreshes.md",
    "metadata": {},
    "heading": "No Heading",
    "content": "b\n---\ntitle: Automatic refreshes\ntable_of_contents: true\n---"
  },
  {
    "filepath": "\\reference\\automatic-refreshes.md",
    "metadata": {},
    "heading": "# Automatic refreshes",
    "content": "Installed snaps are automatically refreshed a few times a day, assuming a different revision is available on the channel being tracked.\n\nMore details about when it is to be triggered may be obtained via:\n\n```bash\n$ snap refresh --time\ntimer: 00:00~24:00/4\nlast: today at 09:08 BST\nnext: today at 15:09 BST\n```\n\nCheck the state of recent updates with:\n\n```bash\n$ snap changes\nID   Status  Spawn               Ready               Summary\n870  Done    today at 09:08 BST  today at 09:10 BST  Auto-refresh snap \"core\"\n```\n\nand to view the details for a specific update, pass its ID to the *change* command:\n\n```bash\n$ snap change 870\nStatus  Spawn               Ready               Summary\nDone    today at 09:08 BST  today at 09:08 BST  Ensure prerequisites for \"core\" are available\nDone    today at 09:08 BST  today at 09:08 BST  Download snap \"core\" (7999) from channel \"edge\"\nDone    today at 09:08 BST  today at 09:08 BST  Fetch and check assertions for snap \"core\" (7999)\nDone    today at 09:08 BST  today at 09:08 BST  Mount snap \"core\" (7999)\nDone    today at 09:08 BST  today at 09:08 BST  Run pre-refresh hook of \"core\" snap if present\nDone    today at 09:08 BST  today at 09:08 BST  Stop snap \"core\" services\nDone    today at 09:08 BST  today at 09:08 BST  Remove aliases for snap \"core\"\nDone    today at 09:08 BST  today at 09:08 BST  Make current revision for snap \"core\" unavailable\nDone    today at 09:08 BST  today at 09:08 BST  Copy snap \"core\" data\nDone    today at 09:08 BST  today at 09:09 BST  Setup snap \"core\" (7999) security profiles\nDone    today at 09:08 BST  today at 09:09 BST  Make snap \"core\" (7999) available to the system\nDone    today at 09:08 BST  today at 09:10 BST  Automatically connect eligible plugs and slots of snap \"core\"\nDone    today at 09:08 BST  today at 09:10 BST  Set automatic aliases for snap \"core\"\nDone    today at 09:08 BST  today at 09:10 BST  Setup snap \"core\" aliases\nDone    today at 09:08 BST  today at 09:10 BST  Run post-refresh hook of \"core\" snap if present\nDone    today at 09:08 BST  today at 09:10 BST  Start snap \"core\" (7999) services\nDone    today at 09:08 BST  today at 09:10 BST  Remove data for snap \"core\" (7977)\nDone    today at 09:08 BST  today at 09:10 BST  Remove snap \"core\" (7977) from the system\nDone    today at 09:08 BST  today at 09:10 BST  Clean up \"core\" (7999) install\nDone    today at 09:08 BST  today at 09:10 BST  Run configure hook of \"core\" snap if present\nDone    today at 09:08 BST  today at 09:10 BST  Run health check of \"core\" snap\nDone    today at 09:08 BST  today at 09:10 BST  Consider re-refresh of \"core\"\n\n......................................................................\nMake snap \"core\" (7999) available to the system\n\n2019-10-14T09:09:13+01:00 INFO Requested daemon restart.\n\n......................................................................\nAutomatically connect eligible plugs and slots of snap \"core\"\n\n2019-10-14T09:09:13+01:00 INFO Waiting for restart...\n2019-10-14T09:10:00+01:00 INFO cannot auto-connect slot core:bluez to bluez:client, candidates found: core:bluez, bluez:service\n\n......................................................................\nConsider re-refresh of \"core\"\n\n2019-10-14T09:10:06+01:00 INFO No re-refreshes found.\n```\n\nFor more details on *snap refresh*, see [Keeping snaps up to date](https://snapcraft.io/docs/keeping-snaps-up-to-date)."
  },
  {
    "filepath": "\\reference\\core-configuration.md",
    "metadata": {
      "title": "Ubuntu Core configuration",
      "table_of_contents": true
    },
    "heading": "# Ubuntu Core configuration (part 1)",
    "content": "Ubuntu Core supports a set of system-wide options that allow you to customise your\nsnap and core environment.\n\nAs with [Configuration in snaps](/t/configuration-in-snaps/510), these options are changed with the `set` and `get` commands, but with a target of  *system* instead of a specific snap:\n\n```bash\n$ snap set system some.option=\"some value\"\n$ snap get system some.option\n```\n\nConfiguration options can be unset by either passing their names to the unset command or by \nadding an exclamation mark (!) to the end of an option name: (from _snapd 2.41+_):\n\n```bash\n$ snap unset system some.option\n$ # or\n$ snap set system some.option!\n```\nTyping `snap get system` outputs a top-level view of system-wide option categories which can be added as arguments to view their contents:\n\n```bash\n$ snap get system\nKey           Value\nexperimental  {...}\nrefresh       {...}\nseed          {...}\n$ snap get system experimental\nKey                   Value\nexperimental.hotplug  true\nexperimental.layouts  true\n```\n---\n\n| Supported options | |\n|--|--|\n| [pi-config](#heading--pi-config) | [proxy.{http,https,ftp}](#heading--proxy) |\n| [refresh](#heading--refresh)| [resilience.vitality-hint](#heading-resiliance) | \n| [service.console-conf.disable](#heading--console)| [service.ssh.disable](#heading--ssh)| \n|[snapshots.automatic.retention](#heading--snapshots-automatic-retention) | [store-certs](#heading--store-certs) | \n| [system.disable-backlight](#heading--backlight) | [system.power-key-action](#heading--power-key-action)| \n| [system.system.timezone](#heading--timezone) ||\n\n---\n\n<h2 id=\"heading--pi-config\">pi-config</h2>\n\nOn a Raspberry Pi, the following options set corresponding values in the _config.txt_ system configuration file:\n\n  * pi-config.disable-overscan\n  * pi-config.framebuffer-width\n  * pi-config.framebuffer-height\n  * pi-config.framebuffer-depth\n  * pi-config.framebuffer-ignore_alpha\n  * pi-config.overscan-left\n  * pi-config.overscan-right\n  * pi-config.overscan-top\n  * pi-config.overscan-bottom\n  * pi-config.overscan-scale\n  * pi-config.display-rotate\n  * pi-config.hdmi-group\n  * pi-config.hdmi-mode\n  * pi-config.hdmi-drive\n  * pi-config.avoid-warnings\n  * pi-config.gpu-mem-256\n  * pi-config.gpu-mem-512\n  * pi-config.gpu-mem\n\nFurther details on the above, see the [official Raspberry Pi documentation](https://www.raspberrypi.org/documentation/configuration/config-txt/).\n\n<h2 id=\"heading--proxy\">proxy.{http,https,ftp}</h2>\n\nThese options may be set to change the proxies to be used by the system when communicating with external sites that speak the respective protocols.\n\nAvailable since snapd 2.28.\n\n<h2 id=\"heading--refresh\">refresh</h2>\n\nThere are four system-wide options that are used to manage how updates are handed:\n\n- **refresh.timer**: defines the refresh frequency and schedule\n- **refresh.hold**: delays the next refresh until the defined time and date\n- **refresh.metered**: pauses refresh updates when network connection is metered\n- **refresh.retain**: sets how many revisions of a snap are stored on the system\n\nSee [Controlling updates](/t/managing-updates/7022#heading--controlling-updates) for further details on how the above options are used.\n\n<h2 id='heading--resiliance'>resilience.vitality-hint</h2>\n\nThis option adjusts the Linux kernel's out-of-memory ([OOM](https://www.kernel.org/doc/gorman/html/understand/understand016.html)) killer behaviour for specific snap services.\n\nBy default, all snap services have the same value for systemd's `OOMScoreAdjust`. By passing a list of snaps ordered by decreasing importance to the `resilience.vitality-hint` system option, the order is respected if snap processes are killed in low memory situations.\n\nThe list of snaps need to be as string containing comma separated snap instance names in decreasing order of importance, such as:\n\n```bash\nsnapA,snapB,snapC\n```\n\nIn the above example, services inside `snapA` are the **least likely** to be killed in _out of memory_ situations, followed by services in `snapB`, services in `snapC`, and then the services in all the other snaps not referenced by the `vitality-hint` option.\n\n[note]\n:information_source: Snaps added to `resilience.vitality-hint` are still _more likely_ to be killed than the snap daemon, snapd, itself.\n[/note]\n\nAvailable since snapd 2.46.\n\n<h2 id=\"heading--console\">service.console-conf.disable</h2>\n\nMay be set to _true_ to disable the console-conf system configuration wizard that is launched by default when booting an initialised Ubuntu Core image.\n\nAvailable since snapd 2.46.\n\n<h2 id=\"heading--ssh\">service.ssh.disable</h2>\n\nMay be set to _true_ to disable the SSH service at startup.\n\nAvailable since snapd 2.22.\n\n<h2 id='heading--snapshots-automatic-retention'>snapshots.automatic.retention</h2>\n\n[Automatic snapshot](/t/snapshots/9468) retention time is configured with the `snapshots.automatic.retention` system option. The default value is 31 days, and the value needs to be greater than 24 hours:\n\n```bash\n$ snap set syst"
  },
  {
    "filepath": "\\reference\\core-configuration.md",
    "metadata": {
      "title": "Ubuntu Core configuration",
      "table_of_contents": true
    },
    "heading": "# Ubuntu Core configuration (part 2)",
    "content": "em snapshots.automatic.retention=30h\n```\nTo disable automatic snapshots, set the retention time to `no`:\n\n```bash\n$ snap set system snapshots.automatic.retention=no\n```\n\n> ⓘ Disabling automatic snapshots will *not* affect preexisting, automatically generated snapshots, but only those generated by subsequent snap removals.\n\nAutomatic snapshots require snap version _2.39+_. \n\n<h2 id='heading--store-certs'>store-certs</h2>\n\nA custom SSL certificate can be added to snapd'd trusted certificates pool for the store communication with the `store-certs.<name>=<value>` system option.\n\nTo add a certificate, enter the following:\n\n```bash\n$ snap set system store-certs.cert1=\"$(cat /path/to/mycert)\"\n```\n\nA certificate can be removed with _unset_:\n\n```bash\n$ snap unset system store-certs.cert1\n```\n\nAvailable since snapd 2.45\n\n<h2 id='heading--backlight'>system.disable-backlight-service</h2>\n\nMay be set to _true_ to disable the backlight service.\n\nAvailable since snapd 2.46.\n\n\n<h2 id='heading--power-key-action'>system.power-key-action</h2>\n\nDefines the behaviour of the system when the power key is pressed.\n\nMay be set to one of:\n\n* ignore\n* poweroff\n* reboot\n* halt\n* kexec\n* suspend\n* hibernate\n* hybrid-sleep\n* lock\n\nAvailable since snapd 2.23.\n\n<h2 id='heading--timezone'>system.timezone</h2>\n\nMay be used to set a time zone value, as typically found in `/usr/share/zoneinfo`, such as `America/Chicago`.\n\nAvailable since snapd 2.46."
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# Gadget snap",
    "content": "The gadget snap is responsible for defining and manipulating system properties\nspecific to one or more devices. \n\nIt contains device-specific support code and data, and is produced and signed\nby the device [brand](https://snapcraft.io/docs/glossary#heading--brand-store)\nvia a [model assertion](assertions/model.md).\n\nThe gadget snap may encode the mechanisms for device initialisation, key\ngeneration and identity certification, as well as particular processes for the\nlifecycle of the device, such as factory resets.\n\n It is perfectly possible for different models to share a gadget snap."
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "## Setup files",
    "content": "In addition to traditional snap metadata, the gadget snap also holds some setup files fundamental to the initialization and lifecycle of the device:\n\n- `meta/snap.yaml` - Traditional snap details, with `type: gadget` explicitly defined.\n- `meta/gadget.yaml` - Gadget-specific information. See below.\n- `grub.conf` - Required grub configuration when using this bootloader.\n- `u-boot.conf` - Required u-boot configuration when using this bootloader.\n- `cloud.conf` - Optional [cloud-init](https://cloudinit.readthedocs.io/en/latest/) configuration; cloud-init is disabled if missing.\n\nSample configuration files may be found in the reference gadget snaps:\n\n- [Raspberry Pi (2B, 3B, 3A+, 3B+, 4B, Compute Module 3, and Compute Module 3+)](https://github.com/snapcore/pi-gadget)\n- [Beagleblack](https://github.com/ogra1/beaglebone-gadget)\n- [Dragonboard](https://github.com/snapcore/dragonboard-gadget)\n- [amd64](https://github.com/snapcore/pc-amd64-gadget)\n- [i386](https://github.com/snapcore/pc-i386-gadget)"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "## The gadget.yaml file",
    "content": "Four YAML keys are used to describe your target device:\n\n* `defaults` (YAML sub-section, optional): default configuration options for\n  the defined snaps, applied on installation.\n\n```yaml\ndefaults:\n    <snap id>:\n        <key>: <value>\n```\n\n* `device-tree` (filename, optional): the Device Tree Blob path. If device-tree\n  is specified, `dtbs/filename` must exist in kernel or gadget snap (depends on\norigin) and `snap_device_tree_origin` and `snap_device_tree` are made available\nfor u-boot and grub.\n* `device-tree-origin` (string, optional): `kernel` or `gadget` (default)\n  depending if the DTB is located in the kernel or in the gadget snap.\n* `volumes` (YAML sub-section, required): the volumes layout, where each disk\n  image is represented as a YAML sub-section."
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "### The `volumes` sub-section",
    "content": "Each volume is described by:\n\n* a name (required)\n* a partition structure (required)\n* a bootloader definition (`grub`, `u-boot`)\n* a partitioning schema eg. `mbr`\n\nVolumes define the structure and content of the images to be written into one\nor more block devices of the gadget device. Each volume in the structure\nrepresents a different image for a \"disk\" in the device."
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "### Specification",
    "content": "The `meta/gadget.yaml` file contains the basic metadata for gadget-specific\nfunctionality, including a detailed specification of which structure items\ncompose an image. The latter is used both by snapd and by ubuntu-image when\ncreating images for these devices.\n\nA gadget snap's boot assets can also be automatically updated when the snap is\nrefreshed. See [Updating gadget boot\nassets](https://snapcraft.io/docs/gadget-boot-assets) for further details.\n\nThe following specification defines what is supported in `gadget.yaml`:\n</br>\n<details>\n<summary>**gadget.yaml specification**</summary>\n\n```yaml"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# the supported one. (optional)",
    "content": "format: <int>"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# configuration. (optional)",
    "content": "defaults:\n    <snap id>:\n        <key>: <value>"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# (since 2.34) (optional)",
    "content": "connections:\n   -  plug: <plug snap id>:<plug>\n      slot: <slot snap id>:<slot>"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# and `snap_device_tree` are made available for u-boot and grub. (optional)",
    "content": "device-tree: <filename>"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# Defines where the device tree is. Defaults to gadget. (optional)",
    "content": "device-tree-origin: kernel"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# (optional) (part 1)",
    "content": "volumes:\n\n  # Name of volume and output image file. Must match [a-z-]+. (required)\n  <volume name>:\n\n    # 2-digit hex code for MBR disk ID or GUID for GPT disk id. (optional)\n    id: <id>\n                  \n    # Bootloader in the volume. Required in one volume. (required/optional)\n    bootloader: grub | u-boot\n\n    # Which partitioning schema to use. Defaults to gpt. (optional)\n    schema: mbr | gpt | mbr,gpt\n\n    # Structure defines layout of the volume, including partitions,\n    # Master Boot Records, or any other relevant content. (required)\n    structure:\n      - # Structure value is a list.\n\n        # Structure item name. There's an implementation-specific constraint\n        # on the maximum length. The maximum length of a partition name\n        # for GPT is 36 characters in the UTF-16 character set. (optional)\n        name: <name>\n\n        # GPT unique partition id, disallowed on MBR volumes. (optional)\n        id: <id>\n\n        # Role defines a special role for this item in the image. (optional)\n        # Must be either unset, or one of:\n        #   mbr - Master Boot Record of the image.\n        #   system-boot - Partition holding the boot assets.\n        #   system-data - Partition holding the main operating system data.\n        #   system-boot-image - Partition holding kernel images for the Little Kernel bootloader.\n        #   system-boot-select - Partition holding state for snapd Little Kernel support.\n        #\n        # A structure with role:system-data must either have an implicit\n        # file system label, or 'writable'.\n        # A structure with role:system-boot-select must have 'snapbootsel' label.\n        role: mbr | system-boot | system-data | system-boot-image | system-boot-select\n\n        # Type of structure. May be specified as a two-hex-digit MBR partition\n        # type, a GPT partition type GUID, or both on hybrid schemas.  The\n        # special value `bare` says to not create a disk partition for this\n        # structure. (required)\n        type: <mbr type> | <gpt guid> | <mbr type>,<gpt guid> | bare\n\n        # Size for structure item. Maximum of 446 for the mbr role. (required)\n        size: <bytes> | <bytes/2^20>M | <bytes/2^30>G\n\n        # The offset from the beginning of the image. Defaults to right after\n        # prior structure item. (optional)\n        offset: <bytes> | <bytes/2^20>M | <bytes/2^30>G\n\n        # Offset of this structure element (in units of 512-byte sectors) is\n        # written to the provided position within the volume in LBA48 pointer\n        # format (32-bit little-endian). This position may be specified as a\n        # byte-offset relative to the start of another named structure item.\n        # (optional)\n        offset-write: [<name>+]<bytes> |\n                      [<name>+]<bytes/2^20>M |\n                      [<name>+]<bytes/2^30>G\n\n        # Filesystem type. Defaults to none. (optional)\n        filesystem: none | vfat | ext4\n\n        # Filesystem label. Defaults to name of structure item. (optional)\n        filesystem-label: <label>\n\n        # Content to be copied from gadget snap into the structure. This\n        # field takes a list of one of the following formats. (required)\n        content:\n\n            # Copy source (relative to gadget base directory) into filesystem\n            # at target (relative to root). Directories must end in a slash.\n            - source: <filename> | <dir>/  # (required)\n              target: <filename> | <dir>/  # (required)\n\n            # Dump image (relative to gadget base directory) of the raw data\n            # as-is into the structure at offset. If offset is omitted it\n            # defaults to right after prior content item. If size is omitted,\n            # defaults to size of contained data.\n            - image: <filename>                                 # (required)\n              offset: <bytes> | <bytes/2^20>M | <bytes/2^30>G   # (optional)\n              offset-write: (see respective item above)         # (optional)\n              size: <bytes> | <bytes/2^20>M | <bytes/2^30>G     # (optional)\n\n        # Support automatic asset updates. (optional)\n        update:\n            # update only if new edition is higher than old edition.\n            edition: uint32\n            # This field takes a list of files to be preserved.\n            # No support for preserving inside images. \n            # i.e. update will overwrite the whole image in this case.\n            preserve: \n              - <filename>\n```\n\n</details>\n\n</br>\n\n<details>\n<summary>**Example: Raspberry Pi 3 gadget.yaml**</summary>\n\n```yaml\n    device-tree: bcm2710-rpi-3-b.dtb\n    volumes:\n      pi3:\n        schema: mbr\n        bootloader: u-boot\n        structure:\n          - type: 0C\n            filesystem: vfat\n            filesystem-label: system-boot\n            size: 128M\n            content:\n              - source: boot-assets/\n                target: /\n```\n\nUsed with the following directory structure:\n\n    .\n    ├── boot-assets\n    │   ├── (...)"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# (optional) (part 2)",
    "content": "│   └── bcm2710-rpi-3-b.dtb\n    ├── meta\n    │   ├── (...)\n    │   ├── gadget.yaml\n    │   └── snap.yaml\n    ├── (...)\n    └── README\n\n</details>\n\n<a name=\"prepare-device\"></a>"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "## prepare-device hook",
    "content": "The optional `prepare-device` hook will be called on the gadget at the start of\nthe device initialisation process, after the gadget snap has been installed.\nThe hook will also be called if this process is retried later from scratch in\ncase of initialisation failures.\n\nThe device initialisation process is, for example, responsible for setting the\nserial identification of the device through an exchange with a device service.\nThe `prepare-device` hook can for example redirect this exchange and\ndynamically set options relevant to it. \n\nOne must ensure that `registration.proposed-serial`  is set to a value\n**unique**  across all devices of the brand and model and that it does not\ncontain a `/`. It is going to be used as the \"serial number\" (a string, not\nnecessarily a number) part of the identification in case the device service\nsupports setting it or **requires** it, as is the case with the *serial-vault*.\n\n</br>\n<details>\n<summary>**Example: prepare-device hook**</summary>\n\n```bash\n#!/bin/sh"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# optionally set the url of the service",
    "content": "snapctl set device-service.url=\"https://device-service\""
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# set optional extra HTTP headers for requests to the service",
    "content": "snapctl set device-service.headers='{\"token\": \"TOKEN\"}'"
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# this might need to be obtained dynamically",
    "content": "snapctl set registration.proposed-serial=\"DEVICE-SERIAL\""
  },
  {
    "filepath": "\\reference\\gadget.md",
    "metadata": {
      "title": "Gadget snap format",
      "table_of_contents": true
    },
    "heading": "# this might need to be obtained dynamically",
    "content": "snapctl set registration.body='mac: \"00:00:00:00:ff:00\"'\n\n```\n</details>"
  },
  {
    "filepath": "\\reference\\assertions\\account-key.md",
    "metadata": {
      "title": "account-key assertion"
    },
    "heading": "# account-key assertion",
    "content": "The account-key assertion holds a public key belonging to an account.\n\nThe format is as follows:\n\n```text\ntype:                account-key\nauthority-id:        <authority account id>\nrevision:            <int>\npublic-key-sha3-384: <key id/sha3-384 digest of the key>\naccount-id:          <account id>\nname:                <human readable key name>\nsince:               <UTC datetime>\nuntil:               <UTC datetime>\nsign-key-sha3-384:   <key id> # Encoded key id of signing key\n\nBODY: base64 encoded version prefixed public key packet\n\n<signature>                 # Encoded signature\n```\n\nThe index for this assertion is `public-key-sha3-384`. The key is valid in the\ntime interval specified by `since` and `until`, being valid forever if `until`,\nwhich is optional, is not defined.\n\n`public-key-sha3-384` is the SHA3-384 hash of the (decoded) body content. The\nbody itself is a format version byte (0x1 for now) followed by the public key\npacket itself. The version 1 public key packet is a constrained/normalized\nRFC4880 public key packet (v4, new header format, algorithm fixed to RSA,\ntimestamp fixed as well).\n\nThe digest of the public key (`public-key-sha3-384`) is used for the lookup of keys\nwhen verifying signatures: all assertions reference their signing key by\nproviding this digest in a `sign-key-sha3-384` header.\n\nNote that when validating an `account-key` it is essential to check that the digest\nmatches the assertion body, besides the signature validation performed for all\nassertions.\n\nThis kind of assertion is used to transmit key information beween the store\nand snapd so the later can validate assertions signed by the key owner. It\nis one of the assertions that you get when downloading a package with\n`sudo download <snap name>`.\n\nAs an example, Canonical's public key for the store is\n\n```text\ntype: account-key\nauthority-id: canonical\nrevision: 2\npublic-key-sha3-384: BWDEoaqyr25nF5SNCvEv2v7QnM9QsfCc0PBMYD_i2NGSQ32EF2d4D0hqUel3m8ul\naccount-id: canonical\nname: store\nsince: 2016-04-01T00:00:00.0Z\nbody-length: 717\nsign-key-sha3-384: -CvQKAwRQ5h3Ffn10FILJoEZUXOv6km9FwA80-Rcj-f-6jadQ89VRswHNiEB9Lxk\n\nAcbBTQRWhcGAARAA0KKYYQWuHOrsFVi4p4l7ZzSvX7kLgJFFeFgOkzdWKBTHEnsMKjl5mefFe9ji\nqe8NlmJdfY7BenP7XeBtwKp700H/t9lLrZbpTNAPHXYxEWFJp5bPqIcJYBZ+29oLVLN1Tc5X482R\nvCiDqL8+pPYqBrK2fNlyPlNNSum9wI70rDDL4r6FVvr+osTnGejibdV8JphWX+lrSQDnRSdM8KJi\nUM43vTgLGTi9W54oRhsA2OFexRfRksTrnqGoonCjqX5wO3OFSaMDzMsO2MJ/hPfLgDqw53qjzuKL\nIec9OL3k5basvu2cj5u9tKwVFDsCKK2GbKUsWWpx2KTpOifmhmiAbzkTHbH9KaoMS7p0kJwhTQGA\no9aJ9VMTWHJc/NCBx7eu451u6d46sBPCXS/OMUh2766fQmoRtO1OwCTxsRKG2kkjbMn54UdFULl9\nVfzvyghMNRKIezsEkmM8wueTqGUGZWa6CEZqZKwhe/PROxOPYzqtDH18XZknbU1n5lNb7vNfem9F\n2ai+3+JyFnW9UhfvpVF7gzAgdyCqNli4C6BIN43uwoS8HkykocZS/+Gv52aUQ/NZ8BKOHLw+7ant\nQ0o8W9ltSLZbEMxFIPSN0stiZlkXAp6DLyvh1Y4wXSynDjUondTpej2fSvSlCz/W5v5V7qA4nIcG\nvUvV7RjVzv17ut0AEQEAAQ==\n\nAcLDXAQAAQoABgUCV83k9QAKCRDUpVvql9g3IBT8IACKZ7XpiBZ3W4lqbPssY6On81WmxQLtvsMV\nWTp6zZpl/wWOSt2vMNUk9pvcmrNq1jG9CuhDfWFLGXEjcrrmVkN3YuCOajMSPFCGrxsIBLSRt/bP\nnrKykdLAAzMfG8rP1d82bjFFiIieE+urQ0Kcv09Jtdvavq3JT1Tek5mFyyfhHNlQEKOzWqmRWiLg\n3c3VOZUs1ZD8TSlnuq/x+5T0X0YtOyGjSlVxk7UybbyMNd6MZfNaMpIG4x+mxD3KHFtBAC7O6kLe\neX3i6j5nCY5UABfA3DZEAkWP4zlmdBEOvZ9t293NaDdOpzsUHRkoi0Zez/9BHQ/kwx/uNc2WqrYm\ninCmu16JGNeXqsyinnLl7Ghn2RwhvDMlLxF6RTx8xdx1yk6p3PBTwhZMUvuZGjUtN/AG8BmVJQ19\nrsGSRkkSywvnhVJRB2sudnrMBmNS2goJbzSbmJnOlBrd2WsV0T9SgNMWZBiov3LvU4o2SmAb6b+k\nrYwh8H5QHcuuYJuxDjFhPswIp6Wes5T6hUicf3SWtObcDS4HSkVS4ImBjjX9YgCuFy7QdnooOWEY\naPvkRw3XCVeYq0K6w9GRsk1YFErD4XmXXZjDYY650MX9v42Sz5MmphHV8jdIY5ssbadwFSe2rCQI\n6UX08zy7RsIb19hTndE6ncvSNDChUR9eEnCm73eYaWTWTnq1cxdVP/s52r8uss++OYOkPWqh5nOu\nhaRn7INjH/yZX4qXjNXlTjo0PnHH0q08vNKDwLhxS+D9du+70FeacXFyLIbcWllSbJ7DmbumGpFo\nyYbtj3FDDPzachFQdIG3lSt+cSUGeyfSs6wVtc3cIPka/2Urx7RprfmoWSI6+a5NcLdj0u2z8O96\nHxeIgxDpg/3gT8ZIuFKePMcLDM19Fh/p0ysCsX+84B9chNWtsMSmIaE57V+959MVtsLu7SLb9gi7\nskrju0pQCwsu2wHMLTNd1f3PTHmrr49hxetTus07HSQUApMtAGKzQilF5zqFjbyaTd4xgQbd+PKW\nCjFyzQTDOcUhXpuUGt/IzlqiFfsCsmbj2K4KdSNYMlqIgZ3Azu8KvZLIhsyN7v5vNIZSPfEbjdeu\nClU9r0VRiJmtYBUjcSghD9LWn+yRLwOxhfQVjm0cBwIt5R/yPF/qC76yIVuWUtM5Y2/zJR1J8OFq\nqWchvlImHtvDzS9FQeLyzJAOjvZ2CnWp2gILgUz0WQdOk1Dq8ax7KS9BQ42zxw9EZAEPw3PEFqRy\nIQsRTONp+iVS8YxSmoYZjDlCgRMWUmawez/Fv5b9Fb/XkO5Eq4e+KfrpUujXItaipb+tV8h5v3tr\noG3Ie3WOHrVjCLXIdYslpL1O4nadqR6Xv58pHj6k\n```"
  },
  {
    "filepath": "\\reference\\assertions\\account.md",
    "metadata": {
      "title": "account assertion"
    },
    "heading": "# account assertion",
    "content": "The account assertion ties a name for an account in the snap universe to its\nidentifier and provides the authority's confidence in the name's validity.\n\nIt is created on user creation by the store, and kept there while the account\nexists.\n\nThe format is as follows:\n\n```text\ntype:              account\nauthority-id:      <authority account id>\nrevision:          <int>\naccount-id:        <account id>\ndisplay-name:      <friendly name for the account>\nusername:          <store user name or nick>\nvalidation:        <uproven|certified>\ntimestamp:         <UTC datetime>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index for this assertion is the `account-id`. Validation `certified` means\nthat the authority is confident in that the display name accurately describes the\nowner of the account, while `unproven` means that no checks have been performed\non that. Header `username` is optional.\n\nRunning `snap known account` gives us a list of the account assertions that\nare present in the system. When a snap is installed, the owner's account assertion\nis downloaded and added to this list.\n\nAn example for this assertion:\n\n```text\ntype: account\nauthority-id: canonical\nrevision: 14\naccount-id: mmOOPWIl0sL7FoSA0KRTt83b1eoynkBa\ndisplay-name: John Smith\ntimestamp: 2017-02-20T10:23:51+00:00\nusername: jsmith\nvalidation: unproven\nsign-key-sha3-384: C9mhxTpowHTXM3HOwgg3ZCX-WD05CczlNMdrCBbl2l0d4J_CcjYBS8NQpI-TtQlL\n\nAcLBXAQAAQoABgUCWKrNXwAKCRC03QWqtcJXZZvwD/9GhSwf9GjiVj9k+x3zVvnHpCPeHDJT0MSJ\nyRsshygdh2njY7o7MWnQbQ3ThOvJsRMAayQejkLd6ro9/gyapJdafCVrTD6/yPrIfN8LaekVGmTL\ntIDluOfQPgboR1a3wA/zXSo077tmbsYTjiZSo73ubNLrEeHi92x7GsECdRVp8B8wPTbgzZUWZOo3\n/p8tXkot7wxqLsjgHbT+DlNSXe491ABM4TxVVYsSltUv+h+GAAfdvV2hMoPENLIVukqkGFq1XRGf\nzBlfODbNRIXoUQ3eFPThYfYdDEVlxF4cKDt2yt9Wcngs31ti5JdGJ7kqL6Hp5rI/Gkdm2dCdvLhf\n+9GDYt1+O9wVSfsZBgcy/shqSwHzP/GyBdPysSRNOSSiS/YFQiTjMWScNM9I1j0oyohlgnV6AOVa\nMeaJFf1Kv90IWL7SP81VZuyqUWcohwuQ5JtphMat2uFqRL0pgH5+btmiWiHCqLqdNJJBIcCpSG+t\nIw1Z27hBm8cmYJW2IFop/fhZxEqggEmzh5hooIuk67he/FLuINuOb4qDlD+hqp6vSz5S9Br/0Gu/\n/0Vr/YCLo9b0xRIeAVZGHxhJMxrELYkGpBv8woaK3hKT53jPxX9tTUwQazYzMhqwZlZSBSFQtnSq\naVrlphWrz4MOmWZ+6HJSx6Qc4p31K/QIVSip14fUYw==\n```"
  },
  {
    "filepath": "\\reference\\assertions\\model.md",
    "metadata": {
      "title": "model assertion"
    },
    "heading": "# model assertion",
    "content": "The model assertion is a statement by a brand about the properties of a device model.\nIt should contain all information needed to create an Ubuntu Core image.\n\nThe format is as follows:\n\n```text\ntype:              model\nauthority-id:      <authority account id>\nrevision:          <int>\nseries             <string>\nbrand-id           <account id>\nserial-authority   <list<string>> # optional list of serial authorities. Use “generic” to have the snap store generate a serial.\nmodel              <model id>\nclassic            <true|false> # optional\nstore              <string> # optional\ndisplay-name       <descriptive string>\narchitecture       <debian architecture name>\ngadget             <gadget snap name>\nkernel             <kernel snap name>\nrequired-snaps     <string>\ntimestamp          <UTC datetime>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index for this assertion is the tuple <`series`, `brand-id`, `model`>. `series`\nallows the brand to define which release of the platform the device uses.\n“rolling” is the name of the development series that bridges stable series,\nwhich have names like “16” or “18”. `brand-id` is the account id of the brand, and `model`\nis a string that identifies a set of devices as desired by the brand.\n\nThe (optional) `classic` flag tells us if this is an all-snap system (false) or not (true).\nIf not set, `architecture`, `gadget`, and `kernel` are mandatory. If set, `kernel`\nis forbidden and `architecture` and `gadget` are optional. If not present, an\nall-snap system is assumed.\n\nThe optional `store` header specifies a particular branded virtual store to be\nused for this model.\nThe store in question has custom content specific to that model, curated by that brand,\nand managed by the store owner or the relevant brand. Each model knows which\nstore it needs to speak to in order to get the appropriate content. If left out\nthe device defaults to use the main Ubuntu store.\n\n`gadget` and `kernel` specify respectively the gadget and kernel snaps used to build\nthe device images. `required-snaps` (optional) is a list of snaps that must be installed at\nall times, and cannot be removed from the device.\n\nThis assertion is needed when [creating an Ubuntu Core device image](../../guides/build-device/image-building.md).\n\nFor instance, this is an Ubuntu Core model assertion for amd64 architecture:\n\n```text\ntype: model\nauthority-id: canonical\nseries: 16\nbrand-id: canonical\nmodel: pc-amd64\narchitecture: amd64\ngadget: pc\nkernel: pc-kernel\ntimestamp: 2016-08-31T00:00:00.0Z\nsign-key-sha3-384: 9tydnLa6MTJ-jaQTFUXEwHl1yRx7ZS4K5cyFDhYDcPzhS7uyEkDxdUjg9g08BtNn\n\nAcLBXAQAAQoABgUCV9A82wAKCRDgT5vottzAEhq1D/4z66k0JS7sQrD54Ccros3HaAABF+7KwGqV\nggg6Mk+N2QKNxpl7fxHeyB82KUy49v4Kp8cg4icPUfrZb1DyzjgyuJIzZfCp1+LLQ4ShJ0ZW9MLW\np7r/FbITtbmGlCKjVtaSwLYTkZNfae/MTTuTB1nLXH939vdicRPtRQ1MsoQ6v8wUYeE4/F+SUxL9\nekYf4G8sz+vzcO5BK9+1T3Wo/aLHDi0N4EOS3K4ia1BVITZKvyeIUEHOLQJAHKk43dAL0PqMFW+W\nIHhDXQoUeiURBfy6zcrRynaIj5tzlhFmJ3pjlmLQLlVCeGJ4yuZ6xb0YIl+oHpYzZrxTad2mEMUY\nsi4qIyxVNGj7LZCloLRsDFBMh8RS9a8L0/Cq3hA2Q1Ugyw2D5U7J427SVYCDS9rrihNVvMFscou6\nvrZHMnAVl/F/TRUDYy29idiiibBQU02D1l4Qu7QnDQQCZygq1n+aeW5ZPwtF/KclkJm0YRUkqbtR\nFG2TYLmQ06MPmRuqVRaAdjfhnZ9YtFBDhI+obn99q/OmG2e7d4WNU3JPG1h5arIQGNeR9kVzBER1\niO0V3iYjD0DxOsd2QVOdI/o8HqCRfycTMo/7TydVdWKXKpKdzeezfz/df2LRDCE712NVFhY0hDC6\nBvV4mMoqS17K7OMHfDohh0DFfp0yFl9oYfLY55G5HA==\n```"
  },
  {
    "filepath": "\\reference\\assertions\\serial.md",
    "metadata": {
      "title": "serial assertion"
    },
    "heading": "# serial assertion",
    "content": "The serial assertion is a statement binding a device identity with the device public key.\n\nEvery Ubuntu Core device belongs to a particular model. It also has a unique\ndevice identity and the ability to prove that identity with cryptographic keys.\nThe precise implementation of this cryptography may vary from device to device,\nbased on the hardware and software capabilities of that device, and is part\nof the gadget snap.\n\nThe format is as follows:\n\n```text\ntype:               serial\nauthority-id:       <authority account id>\nrevision:           <int>\nbrand-id            <account id>\nmodel               <model id>\nserial              <unique id for the device>\ndevice-key          <public key and type>\ndevice-key-sha3-384 <digest of the device key>\ntimestamp           <UTC datetime>\nsign-key-sha3-384:  <key id> # Encoded key id of signing key\n\nBODY: map of hardware constraints/details  # expected to be YAML\n\n<signature>                 # Encoded signature\n```\n\nThe index is the tuple <`brand-id`, `model`, `serial`>, being `serial` a unique\nidentifier for the device. `brand-id` and `model` must match an existing model assertion.\n\nThe crucial information provided by this assertion is the serial which is\na unique identifier for this device in the context of the model. In other words,\nthe brand should never assign the same serial to more than one device of the\nsame model. This assertion must then be signed by the brand.\n\nThe assertion also provides a unique key for the device in the `device-key` header,\nbeing the format the same as for the key in the account-key assertion. A digest\nto identify it is also provided. The device key might change over time, in a\ncontrolled fashion, but at any given time there is only one device key per device.\n\nThe (optional) body will contain device details in YAML format.\n\nThis example was extracted from a kvm Ubuntu Core instance with `sudo snap known serial`:\n\n```text\ntype: serial\nauthority-id: canonical\nbrand-id: canonical\nmodel: pc-amd64\nserial: 03961d5d-26e5-443f-838d-6db046126bea\ndevice-key:\n    AcbBTQRWhcGAARAA0y/BXkBJjPOl24qPKOZWy7H+6+piDPtyKIGfU9TDDrFjFnv3R8EMTz1WNW8d\n    5nLR8gjDXNh3z7dLIbSPeC54bvQ7LlaO2VYICGdzHT5+68Rod9h5NYdTKgaWDyHdm2K1v2oOzmMF\n    Z+MmL15TvP9lX1U8OIVkmHhCO7FeDGsPlsTX2Wz++SrOqG4PsvpYsaYUTHE+oZ+Eo8oySW/OxTmp\n    rQIEUoDEWNbFR5/+33tHRDxKSjeErCVuVetZxlZW/gpCx5tmCyAcBgKoEKsPqrgzW4wUAONaSOGc\n    Zuo35DxwqeGHOx3C118rYrGvqA2mCn3fFz/mqnciK3JzLemLjw4HyVd1DyaKUgGjR6VYBcadL72n\n    YN6gPiMMmlaAPtkdFIkqIp1OpvUFEEEHwNI88klM/N8+t3JE8cFpG6n4WBdHUAwtMmmVxXm5IsM3\n    uNwrZdIBUu4WOAAgu2ZioeHLIQlDGw6dvVTaK+dTe0EXo5j+mH5DFnn0W1L7IAj6rX8HdiM5X5fP\n    4kwiezSfYXJgctdi0gizdGB7wcH0/JynaXA/tI3fEVDu45X7dA/XnCEzYkBxpidNfDkmXxSWt5N/\n    NMuHZqqmNHNfLeKAo1yQ/SH702nth6vJYJaIX4Pgv5cVrX5L429U5SHV+8HaE0lPCfFo/rKRJa9i\n    rvnJ5OGR4TeRTLsAEQEAAQ==\ndevice-key-sha3-384: _4U3nReiiIMIaHcl6zSdRzcu75Tz37FW8b7NHhxXjNaPaZzyGooMFqur0EFCLS6V\ntimestamp: 2016-11-08T18:16:12.977431Z\nsign-key-sha3-384: BWDEoaqyr25nF5SNCvEv2v7QnM9QsfCc0PBMYD_i2NGSQ32EF2d4D0hqUel3m8ul\n\nAcLBUgQAAQoABgUCWCIWcgAARegQAB4/UsBpzqLOYOpmR/j9BX5XNyEWxOWgFg5QLaY+0bIz/nbU\navFH4EwV7YKQxX5nGmt7vfFoUPsRrWO4E6RtXQ1x5kYr8sSltLIYEkUjHO7sqB6gzomQYkMnS2fI\nxOZwJs9ev2sCnqr9pwPC8MDS5KW5iwXYvdBP1CIwNfQO48Ys8SC9MdYH0t3DbnuG/w+EceOIyI3o\nilkB427DiueGwlBpjNRSE4B8cvglXW9rcYW72bnNs1DSnCq8tNHHybBtOYm/Y/jmk7UGXwqYUGQQ\nIwu1W+SgloJdXLLgM80bPzLy+cYiIe1W1FSMzVdOforTkG5mVFHTL/0l4eceWequfcxU3DW9ggcN\nYJx8MPW9ab5gPibx8FeVb6cMWEvm8S7wXIRSff/bkHMhpjAagp+A6dyYsuUwPXFxCvHSpT0vUwFS\nCCPHkPUwj54GjKAGEkKMx+s0psQ3V+fcZgW5TBxk/+J83S/+6AiQ06W8rkabWCRyl2fX81vMBynQ\nnu147uRGWTXfa31Mys9lAGNHMtEcMmA106f2XfATqNK99GlIIjOxqEe5zH3j51JtY+5kyJd9cqvl\nPb0rZnPySeGxnV4Q2403As67AJrIExRrcrK2yXZjEW3G2zTsFNzBSSZr0U8id1UJ/EZLB/em2EHw\nD2FXTwfDiwGroHYUFAEu1DkHx7Sy\n```"
  },
  {
    "filepath": "\\reference\\assertions\\snap-build.md",
    "metadata": {
      "title": "snap-build assertion"
    },
    "heading": "# snap-build assertion",
    "content": "The snap-build assertion defines the basic properties of a snap at the time it\nwas built by the developer. These are assertions are created and uploaded to\nthe store with the command `snapcraft sign-build <snap>`.\n\nCurrently, the only usage of this assertion is to provide traceability between\npublisher and snap. It is not checked by snapd or other parts of the system.\n\nThe format is as follows:\n\n```text\ntype:              snap-build\nauthority-id:      <authority account id>\nrevision:          <int>\nsnap-sha3-384:     <sha3-384 digest as url-safe unpadded base64>\nsnap-id:           <snap-id>\ngrade:             <devel|stable>\nsnap-size:         <int>\ntimestamp:         <UTC datetime>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index is the digest of the snap blob, `snap-sha3-384`. `grade` tells\nus whether the snap can be published to the candidate or stable channel\n(if stable) or not (if devel).\n\nAn example for this assertion:\n\n```text\ntype: snap-build\nauthority-id: ouMZ22pMaY5EVwoLozfjM4fR31bko4yj\nsnap-sha3-384: UFLajZv9twDGKvqorGn7ddN_hMPuq0DNlh24VGblYQZSM7EzcLRKGdxdigi6DUti\ndeveloper-id: ouMZ22pMaY5EVwoLozfjM4fR31bko4yj\ngrade: stable\nsnap-id: xoHNzwxGwQ2D4rSZwI3DKsjtRuy9saeI\nsnap-size: 6840320\ntimestamp: 2017-02-20T12:50:12+01:00\nsign-key-sha3-384: kKl-kgxTJSR-wm5OT5M-gVxo4zv0Y19AAloJE4dq7C0QlbPsdbof0G5g0lCpg0J_\n\nAcLBXAQAAQoABgUCWKrX9AAKCRCuieT/1PiUiBwuD/0fEfBS1IZ62PS0kyRbUDxBEPN3gzgw6mhX\nDaB5bxz2xJ/qQEGfoZdddH7Q45K1lr5pPVL99P2WFwFmdCvWsrcYuK2MZnzwhovD3oPATcFxTnj3\nZttXwW7hDVokdvOwLdyvEaBkuyyO6awidzxFISsqgiaK2DzAwzA6aSXIOaYGDAfALm/YdzvZsfrk\n+jTswZy/jbWlZf0z8C0bQGa/euJAWtzRScucHEK4RxM2qq7hok6AIl9xDBalfZOdlyB01ReM+68z\nKldXoDQlyvMygx63HTXkmirJjWAUiiQ+5rJz9/zn8j84gT+R7qBgWBRd0l9KCZjalEDlXaNjfau3\nNZHJ3FgGqZLx7vkGpqExJEAEDcyiMHj7XV5WSsKTgtTSkE4LvicICYiy6IhgiQ/+2wADMnTRQY0U\n2GuN3amiEQ9873aohlmmnJUUxpchNZHxgUSC0nUprmSgEUBNi4giRrD8Gs5Mji2cy9qk7yqxkXu0\nNjagDzsTHYPo2XlV93cyNJwPbjlshmS0NA/wAJRiwq0AkqgCaZweHuriJeewFnfAg2wyCz1nfh9X\nXWJSX+DR6tLnkZ1evRG9g0a8LzBtKwlrq7+sMAvxglAQlw3JZG/4yRw4NTZJQ4t4+9Eybzkf587f\nSDhf+j3c0JNUgb9o8isewL2+LLcvgM8tTSAmRxYqTw==\n```"
  },
  {
    "filepath": "\\reference\\assertions\\snap-declaration.md",
    "metadata": {
      "title": "snap-declaration assertion"
    },
    "heading": "# snap-declaration assertion",
    "content": "The snap-declaration assertion defines some of the properties of the snap, such\nas the snap-id, the official name, the publisher, and so on. This assertion is\ndownloaded along the snap when installing a snap from a store and has information\non actions to take when performing the installation.\n\nThe format is as follows:\n\n```text\ntype:               snap-declaration\nauthority-id:       <authority account id>\nrevision:           <int>\nseries:             <series this assertion was created for>\nsnap-id:            <string>\nsnap-name:          <string>\npublisher-id:       <the owner of this snap-id space>\ntimestamp:          <UTC datetime>\nrefresh-control:    <list of snap-ids that have gated updates>\n  - [snap-id1]\n  - [snap-id2]\n  - ...\nauto-aliases:       <optional list of aliases that are automatically enabled>\n  - [alias1]\n  - ...\nplugs:              <map from [interface] to plug side rules>\n  [interface]:      <optional plug side rules for [interface]>\n    allow-installation:     <true|false>\n    deny-installation:      <true|false>\n    allow-connection:       <true|false>\n    deny-connection:        <true|false>\n    allow-auto-connection:  <true|false>\n    deny-auto-connection:   <true|false>\n  ...\nslots:              <map from [interface] to slot side rules>\n  [interface]:      <optional slot side rules for [interface]>\n  ...               <similar options as rule entries for plugs>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index is the tuple <`series`, `snap-id`>. `snap-id` is a key with the same\nformat as the account ids.\n\nThis assertion gives control on several aspects of the snap behaviour to the\nthe authority:\n\n* `refresh-control` gives a list of snaps that are gated when the one\nspecified by `snap-id` is installed,\nso they are not automatically refreshed until they are \"validated\".\nValidation is performed by using [validation asserts](validation.md), which specify the\nrevision of the gated snap that should be installed if the gating snap\nhas been installed.\n\n* `auto-aliases` gives a list of the aliases that we want to\nautomatically enable when installing the snap. Aliases provide short\nnames for applications contained in the snap, so we do not need to use\nthe full command name <snap-name>.<command>. They are defined inside snap.yaml,\nbut they are not activated by default unless included in the `auto-aliases`\nlist. Having this inside a signed assertion lets snapd create the aliases\nonly if curated by a trusted authority.\n\n* `plugs` and `slots` define flags per interface. This lets define restrictions\non how the snap plugs/slots used by the snap are handled. For instance, we can\nallow or deny connections with `allow-connection` and `deny-connection`.\nWith `allow-auto-connection` or `deny-auto-connection` we let snapd know\nif it should automatically connect plugs/slots on snap installation.\n\nsnap-declaration assertions for installed snaps can be seen by issuing\n`snap known snap-declaration`.\n\nAs an example, for the modem-manager snap from the Ubuntu store we have:\n\n```text\ntype: snap-declaration\nformat: 1\nauthority-id: canonical\nrevision: 9\nseries: 16\nsnap-id: KtwxgRlwCAVKFw92BUdt1WloH1Va3QPo\nplugs:\n  modem-manager:\n    allow-auto-connection: true\npublisher-id: canonical\nslots:\n  modem-manager:\n    allow-connection: true\nsnap-name: modem-manager\ntimestamp: 2016-10-25T15:35:43.646671Z\nsign-key-sha3-384: BWDEoaqyr25nF5SNCvEv2v7QnM9QsfCc0PBMYD_i2NGSQ32EF2d4D0hqUel3m8ul\n\nAcLBUgQAAQoABgUCWA970AAABF0QAMw+M28Rrm0m/3Gm5PYesQcQWKhGwmN0j3qfYG2LsSRiM0TU\nj7K7hvCPc9v0P4sL6Ewv/CEZAkVxPYd9eUMqiyKYBRMp9QeiL7KW3RWdHok0FUN7ia7ZxcPlpKoM\nuwV7qYDKktw/TJWX9bK15W6DnghlKtU464u7IqcHVmH2YzPBbcpJBuIhLHgYC2K5oj3ZvIjHqnV/\nELRDtwW3UTTkonycc2IUTCd10qu590z7DWzORWdts9ZARBJXfc3lohYkSd1v4wDYZHRO9RF/bJix\nLBALp3kUR6X3OnLLJQAjVhIEY70B/5kLApuhrOpmi84Uawf+Uh91Ze++Bwatrw6QGw9cwkFgoLaj\n9neiV4y6HvQh7gsgXap1XOZeOeWVMISgqaXGER78Lx6nc6/Loz8Yhjp4p9xi2Ia4j7fLpXMkWIU4\naoGudS1hQBsbeiNQvG6I+DraMN7xypMbOkGKwqNJ7prU63D3BmZiFl17ajT3SfffEO1/H6qqRVFS\nA8X9HXVGPmI2TGst36cBgjdd9f+jj9ZqISKs8jdHfPKEpOBdH4wo1rodXO1y/GxZeP2Z710qep4t\n8ynSRPi0l3boyM15D3IfnXMjLzUoace9vC6gltOHpW8GFPZvheQwknRvtfwRpZM2VsgaSw6cuz3+\n7K/m9/Ff04A86/gvRlzduXIjEvKJ\n```"
  },
  {
    "filepath": "\\reference\\assertions\\snap-revision.md",
    "metadata": {
      "title": "snap-revision assertion"
    },
    "heading": "# snap-revision assertion",
    "content": "The snap-revision assertion is a statement by the store acknowledging the\nreceipt of a build of a snap and labeling it with a snap revision.\nIt is one of the assertions that are downloaded along the snap when\nrunning `snap download <snap-name>`.\n\nThe format is as follows:\n\n```text\ntype:              snap-revision\nauthority-id:      <authority account id>\nsnap-sha3-384:     <sha3-384 digest as url-safe unpadded base64>\ndeveloper-id:      <developer account id>\nsnap-id:           <snap-id>\nsnap-revision:     <int>\nsnap-size:         <int>\ntimestamp:         <UTC datetime>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index is the digest of the snap blob, `snap-sha3-384`. The store returns the\n`revision` assigned to the uploaded snap along other data.\n\nAn example of this:\n\n```text\ntype: snap-revision\nauthority-id: canonical\nsnap-sha3-384: F5gwZqB3EBPQ62fhu2CL65TPNdyLbxCVdsxEReYrnp5sNu2z2BXAjdk_BRfUKJgV\ndeveloper-id: canonical\nsnap-id: RmBXKl6HO6YOC2DE4G2q1JzWImC04EUy\nsnap-revision: 44\nsnap-size: 5234688\ntimestamp: 2016-11-03T10:39:25.624109Z\nsign-key-sha3-384: BWDEoaqyr25nF5SNCvEv2v7QnM9QsfCc0PBMYD_i2NGSQ32EF2d4D0hqUel3m8ul\n\nAcLBUgQAAQoABgUCWBsT3QAA/JgQAH+XrRnxFLFzCHVXF5B6yKbj1e5M2YTUXZ3XLHp+eGU93t+h\n54UxBwgSKX/Wb1MliOpWG7IuhIw0WsUzM/Ynq5Ixhmf/f8E5p7hP9JJU6+UJaJCnnLtmRLG3x6Y7\nYmYIPGEvhn8VuznuTCyqyqRdiiu3U1aKecMyKRdKQvfDdJV4XveTuWlCuHjHplJ/apApyZQDCA/O\nQr6grtz/Ud1bR9ThR0KISTuRhE/2qFOuNCVTHU2lFYGrECF0vJYo42tW2R85ZdsOpdVngAMUAJOZ\nREZKML9cgnJqIDwuZ4DNl+684p71+mNeQtbg2608F8fiK2jFJa8mHY5kxhzFGrIPVXEVmPTRlc0Q\ndPdViCOeg4jOuCybKQ/DrzE7Vjqhgl6UbKX2JtLbSxwBuB65YijCTVbqZD+u58ek9N9Z6ZKrJz2o\nHXq6RZqTpkCagV3FIxRRGhBDWQCePY4tRNEj9+3u31Af9daswRlmrFXwWDf46KPKx+fJ9jPECknO\ns+jQ5ij3fpMfWOzceHHLhIDm9Wj7sypD+63v4KDaXzQ+8dM/acMraNAJHRvCOr7bvFz9j7OEqr7y\n/6/QMZdkeYO94e1OPB5e+Dya95oCVqJhf05BAIKOn933EjGT3Vnm7HT+EzCvLUbbjMPlJ6ZyNnp/\nlE+8N8EQWmdLC+OwJRNHgucjvcaR\n```"
  },
  {
    "filepath": "\\reference\\assertions\\system-user.md",
    "metadata": {
      "title": "system-user assertion"
    },
    "heading": "# system-user assertion",
    "content": "The system-user assertion is a permit by the brand for local system users to be\ncreated on its specified devices. The most common use case is for\ncreating system users in the factory line or on first boot, by using a USB\ndongle which would contain this assertion.\n\nThe format is as follows:\n\n```text\ntype:           system-user\nauthority-id:   <authority account-id>\nrevision:       <int>\nbrand-id:       <account-id>\nemail:          <user e-mail>\nseries:         <list of series which should accept this assertion>\nmodels:         <models which should accept this assertion>\nname:           <optional person’s name>\nusername:       <system user name>\npassword:       <encoded password>\nssh-keys:       <list>\nsince:          <UTC datetime>\nuntil:          <UTC datetime>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index is the tuple <`brand-id`, `email`>. `series` is as specified by the\nmodel assertion. These assertions must be signed by the brand.\n\nThe `password` header must be encoded and salted, following the format\nspecified by [crypt](http://manpages.ubuntu.com/manpages/bionic/en/man1/crypt.1.html)(3).\nThe `until` header is in this case required.\n\nThe simple addition of such assertions to a device assertion database should not\nbe enough to trigger the user creation. This must be initiated explicitly (via\n`snap create-user`, or in the context of the auto-import mechanism for\nassertions from removable devices, which requires physical access to the device).\n\nThis would be an example of this assertion:\n\n```text\ntype: system-user\nauthority-id: 324hfanjkfqASdFQWfnawefhu8Jauhdj\nbrand-id: 324hfanjkfqASdFQWfnawefhu8Jauhdj\nemail: test@localhost\nmodels:\n  - pc\nname: Default Test User\npassword: $6$OCvKy4w/Ppxp7IvC$WPzWiIW.4y18h9htjbOuxLZ.sjQ5M2hoSiEu3FpMU0PMdHQuQdBOqvk8p6DMdS/R/nU/rXidClD23CbSkSgp30\nseries:\n  - 16\nsince: 2016-10-24T07:12:10+00:00\nuntil: 2017-10-24T07:12:10+00:00\nusername: test\nsign-key-sha3-384: kKd-kgxTJSR-wm5OT5M-gVxo4zv0Y19AAloJE4dq7C0QlbPsdbof0G5g0lCpg0J_\n\nAcLBXAQAAQoABgUCWKrupwAKCRCuieT/1PiUiMbrD/0WcjG5Yw6kPZ4afE6vePpZfySvPLbguna+\nkMUtTYulfIVNK+VMR3ZeNQfHhe/WGIlxXUWqfIlp6EZ4ha7LBeeHYgdq6cOOrapa53wboQTOTCDp\nEZna2R5lDnlVlm06jKOoPhQZNi0P30GiS9e1xY0CNu/hzxLgwArHYj1hqof0zdu/A68GyfU9AWRe\nne4QGFIwWuQE8vksgbRuCoRiu0zamU6WKdby4pad7Q1SHUdwn8+0i0/zmgRnvDeBloACNWHRYFy3\nPGjJ5ylIkXoBaIYGfYusdO+NvSUnLP4Rj6izsUbBIVeHyAqAkMz6y68NUpQupO4vqih3GSi1pqoj\nH5+p/e5UzcB7hqB8YOrwTtp5EsTPq/AOD0bu9EZdVS5eIAkGuvR3MJX+uGvTAXCCFMIPIxcNTPwp\n6HUiyQ3xMZL6FUg4ucxQH6jRZiZ5SMiuJ2OYl53f7v3MdFMe5lnYSw1nBger9nEXti3pdsS9Czpk\n3WdVRWSjvMupJUmlCJUTNeLwPn2gYCiZpFJntIltRq3McKqh6WrhTozsoVsLjTyx7bQEHp00QycJ\n1pfdMtVNbQKyF30dswc5TctzZEOY/YazMI8CqB3ZuCGyUpkJ0px2FgJQqVHYdtIDePp33aTy170A\n5dHym5SUQZqowwHN/PSc7rTyGn4fJCdRpRsjj72uSQ==\n```"
  },
  {
    "filepath": "\\reference\\assertions\\validation.md",
    "metadata": {
      "title": "validation assertion"
    },
    "heading": "# validation assertion",
    "content": "The validation assertion tells us that a certain revision for a snap that is gated\nby another snap has been validated for a given series. It is closely related to the\n[snap-declaration](snap-declaration.md) assertion.\n\nThe format is as follows:\n\n```text\ntype:                   validation\nauthority-id:           <authority account-id>\nrevision:               <int>\nseries:                 <list of series which should accept this assertion>\nsnap-id:                <snap-id>\napproved-snap-id:       <snap-id>\napproved-snap-revision: <int>\ntimestamp:              <UTC datetime>\nrevoked:                <bool>\nsign-key-sha3-384: <key id> # Encoded key id of signing key\n\n<signature>                 # Encoded signature\n```\n\nThe index is the tuple <`series`, `snap-id`, `approved-snap-id`, `approved-snap-revision`>.\nThis assertion means that refreshing to revision number `revision` of snap\n`approved-snap-id` for `series` has been aproved by `authority-id`, being `snap-id`\nthe snap that was gating the update, of which `authority-id` must be the owner.\n`approved-snap-id` must be part of the `refresh-control` list in the snap-declaration\nassertion of `snap-id` for this to be enforced.\n\nIn other words, the recomended revision for `approved-snap-id` in a system that\nhas `snap-id` installed is the one in the `revision` header. There will be no\nautomatic installation of newer revisions until a validation with a newer revision\nis released by the store. Note however that this does not forbid a forced update\nby the device owner.\n\nThe validation can be revoked by using the optional flag `revoked`.\n\nAn example of this type:\n\n```text\ntype: validation\nauthority-id: canonical\nrevision: 1\nseries: 16\nsnap-id: kkOOPWIl0sF7FoSA0KRTt83b1eoynkBa\napproved-snap-id: JIpOmfrI0JpaN3uNQQgNv5x3fW06nOYX\napproved-snap-revision: 37\ntimestamp: 2017-02-20T10:23:51+00:00\nsign-key-sha3-384: C9mhxTpowHTXM3HOwgg3ZCX-WD05CczlNMdrCBbl2l0d4J_CcjYBS8NQpI-TtQlL\n\nAcLBXAQAAQoABgUCWKrI2QAKCRC03QWqtcJXZRFbEACDcCy15wPNpjcJyFYEt05A4WWzGPQMlC09\n1lv62WAancrRaenLOi3xmeIPgsuPk9xKgrn16dBlytCK5GUHiHsafR+34mt/ridaVSKY5zCIkvcJ\nmgIH3jMB1RZiY2gtlxXD14G+nK67PKvM6BBfMdBB9ItLAdh5LM3ycbE/8ZqY7aYuTLKfOIPYGjUY\n2rRlOaCggeXsru9wbnNwCwGBHZ9ltBgsISZQiSMGnH38OMNgjNOQy0PIB+elmYLEoTKXc+qU1x5w\n/R8cwUzWwcd56Ty/WpGdAfBrpO4/afFgVtGrixEWtVigIoIigPb7wytmQYcnl/Y0bQMVNZiYFQdF\ntZ9MGGTzA/ieRrjJHOQEj+VfDA4rHU2vUTGlZtseukhGNhSNgI52zhDyynhB/Hxy1t0rJ8eJju2a\nG27p2GuJvGrxfjxcge47LZ0WJaKe9R82/AsrFLlnJ4d29K0RUPnYohwlDwWTAOTE2SAz6/kIRNIv\nsOuHdIXIMarsbbRIG1kC++Rl/XI9jWvoM++fT1kHCjXgKfi+CELo8YcOKHPbjWSd7DiAmSnR5I6f\novydzkMPTzzbsxyKePQHicKiqPs4dSfcEnPIGTpvgpGE4WEI3zYGYmsGgFOJqEnuy0IvVRCtJXU4\nyk/p3Jqwss3W0YbfypCWrvMBxho1mN5SRhaQv3r+kw==\n```"
  },
  {
    "filepath": "\\reference\\interfaces\\camera.md",
    "metadata": {
      "title": "camera interface details"
    },
    "heading": "# `camera` interface details",
    "content": "..."
  },
  {
    "filepath": "\\reference\\interfaces\\index.md",
    "metadata": {
      "title": "Core interfaces reference",
      "table_of_contents": true
    },
    "heading": "# Core interfaces reference",
    "content": "This document references all the interfaces available by default on an Ubuntu Core system."
  },
  {
    "filepath": "\\reference\\interfaces\\index.md",
    "metadata": {
      "title": "Core interfaces reference",
      "table_of_contents": true
    },
    "heading": "## Terminology",
    "content": "* Auto-connect: the interface is connected upon snap install\n\n* Transitional: the interface supports traditional desktop features that were not designed with strong application isolation in mind and will be deprecated when a technology more in adequacy with the snap security policy is available."
  },
  {
    "filepath": "\\reference\\interfaces\\index.md",
    "metadata": {
      "title": "Core interfaces reference",
      "table_of_contents": true
    },
    "heading": "## Interfaces (part 1)",
    "content": "| Interface name | Purpose | Auto-connect | Transitional | Attributes |\n|----------------|---------|--------------|--------------|------------|\n| `account-control` | Can add users and change password. Suitable for administration tools. | no | no |  |\n| `camera` | Can access the first video camera. Suitable for programs wanting to use webcams. | no | no |  |\n| `dbus` | Providing snaps implementing a DBus API may be accessed via their well-known DBus connection name (_2.20+_). | no | no | `name` (slot): well-known DBus connection name for the service (eg, `org.foo.bar`)<br> `bus` (slot): DBus bus to use (ie, `session` or `system`)<br> `name` (plug): well-known DBus connection name of the service from the providing snap<br> `bus` (plug): DBus bus to use for providing snap |\n| `gsettings` | Can access global gsettings of the user\\'s session which gives privileged access to sensitive information stored in gsettings and allows adjusting settings of other applications. | yes | yes |  |\n| `home` | Can access non-hidden files in user\\'s `$HOME` and gvfs mounted directories owned by the user to read/write/lock. | yes on classic (traditional distributions), no otherwise | yes |  |\n| `mpris` | Providing snaps implementing the Media Player Remote Interfacing Specification (mpris) may be accessed via their well-known DBus name. | no | no | `name` (slot): optional, media player name to use for DBus well-known name |\n| `network` | Can access the network as a client. | yes | no |  |\n| `network-bind` | Can access the network as a server. | yes | no |  |\n| `opengl` | Can access OpenGL hardware. | yes | no |  |\n| `optical-drive` | Can access the first optical drive in read-only mode. Suitable for CD/DVD playback. | yes | no |  |\n| `password-manager-service` | Can access global password manager services provided by popular Desktop Environment (eg, Secret Service and KWallets) which gives privileged access to sensitive information stored in the user\\'s session (_2.27+_). | no | yes |  |\n| `pulseaudio` | Can access the PulseAudio sound server which allows for sound playback in games and media application. Recording not supported but will be in a future release. | yes | no |  |\n| `removable-media` | Can access files from removable media in /media and /run/media | no | no |  |\n| `screen-inhibit-control` | Can access desktop session manager screen inhibit and uninhibit functionality. | yes | no |  |\n| `shutdown` | Can control the system power state and rebooting, powering off or halting the system. | no | no |  |\n| `unity7` | Can access Unity7. Unity 7 runs on X and requires access to various DBus services. This interface grants privileged access to the user\\'s session since the Unity 7 environment does not prevent eavesdropping or apps interfering with one another. | yes | yes |  |\n| `wayland` | Can access compositors supporting the wayland protocol  (_2.28+_). | yes | no |  |\n| `x11` | Can access the X server which gives privileged access to the user\\'s session since X does not prevent eavesdropping or apps interfering with one another. | yes | yes |  |\n| `account-control` | Can create and delete non-system extra users and change the password for non-system extra users (_2.22+_). | no | no |  |\n| `alsa` | Can directly access ALSA devices in /dev/snd. | no | no |  |\n| `autopilot-introspection` | Can be introspected by autopilot (_2.24+_). | no | no |  |\n| `avahi-control` | Can access and control snaps providing Avahi mDNS/DNS-SD services on the network which gives privileged access to the service (_2.28+_). | no | no |  |\n| `avahi-observe` | Can access snaps providing Avahi to browse for mDNS/DNS-SD services on the network. | no | no |  |\n| `bluetooth-control` | Allow to manage the kernel side Bluetooth stack. | no | no |  |\n| `bluez` | Can access snaps providing the bluez interface which gives privileged access to bluetooth. | no | no |  |\n| `broadcom-asic-control` | Can access broadcom-asic devices and sysfs interfaces (_2.28+_). | no | no |  |\n| `browser-support` | Can access files and IPC needed by modern browsers. This interface is intended to be used when using an embedded Chromium Content API or using the sandboxes in major browsers from vendors like Google and Mozilla. The `allow-sandbox` attribute may be used to give the necessary access to use the browser\\'s sandbox functionality. | yes | no | `allow-sandbox:` true or false (defaults to ``false``) |\n| `classic-support` | Allows resources necessary for running as classic dimension snap which gives device ownership to the snap. This interface is reserved for the `classic` snap (_2.23_). | no | no |  |\n| `content` | Can access content from the providing snap from within the consuming snap\\'s filesystem area. | yes for snaps from same publisher, no otherwise | no | `read` (slot): read-only paths from providing snap to expose to the consuming snap<br> `write` (slot): read-write paths from providing snap to expose to the consuming snap<br> `content` (slot): reference to plug si"
  },
  {
    "filepath": "\\reference\\interfaces\\index.md",
    "metadata": {
      "title": "Core interfaces reference",
      "table_of_contents": true
    },
    "heading": "## Interfaces (part 2)",
    "content": "de of connection. Defaults to local slot name<br> `default-provider` (plug): name preferred providing snap<br> `target` (plug): path in consuming snap to find providing snap\\'s files<br> `content` (plug): reference to slot side of connection. Defaults to local plug name |\n| `core-support` | Can control all aspects of systemd via the systemctl command, update rsyslog configuration, update systemd-timesyncd configuration and update/apply sysctl configuration which gives privileged access to the system (_2.22+_). Reserved for `core` snaps (`type: os`).  | no | no |  |\n| `cups-control` | Can access cups control socket which gives privileged access to configure printing. | no | no |  |\n| `dcdbas-control` | Can interact with the Dell Systems Management Base Driver which provides a sysfs interface for systems management software such as Dell OpenManage to perform system management interrupts and host control actions (system power cycle or power off after OS shutdown) on certain Dell systems. | no | no |  |\n| `docker` | Can access snaps providing the docker interface which gives privileged access to the system. | no | no |  |\n| `docker-support` | Can access resources and syscalls necessary to run Docker application containers. The `privileged-containers` attribute may be used to give the necessary access to run privileged containers. Providing snaps specifying this interface currently may only be established with the Docker project. | no | no | `privileged-containers` (plug): true or false (defaults to ``false``) |\n| `firewall-control` | Can configure network firewalling giving privileged access to networking. | no | no |  |\n| `framebuffer` | Can use the universal framebuffer (/dev/fb[0-9]*, (_2.22+_)). | no | no |  |\n| `fuse-support` | Can mount fuse filesystems (as root only). | no | no |  |\n| `fwupd` | Can access snaps providing the fwupd interface which gives privileged access to update UEFI capsule format firmware. | no | no |  |\n| `gpio` | Can access GPIO devices. This is restricted because it provides privileged access to GPIO hardware. | no | no |  |\n| `greengrass-support` | Can access resources and syscalls necessary to run Amazon Greengrass services and lambda functions. Providing snaps specifying this interface currently may only be established with the Amazon Greengrass project  (_2.26+_). | no | no |  |\n| `hardware-observe` | Can query hardware information from the system. | no | no |  |\n| `hardware-random-control` | Allow read/write access to `/dev/hwrng` (_2.25+_). | no | no |  |\n| `hardware-random-observe` | Allow read access to `/dev/hwrng` (_2.25+_). | no | no |  |\n| `hidraw` | Can access hidraw devices. This is restricted because it provides privileged access to hardware devices. | no | no |  |\n| `i2c` | Can access i2c devices. This is restricted because it provides privileged access to hardware devices. | no | no |  |\n| `iio` | Can access IIO devices. This is restricted because it provides privileged access to IIO hardware (_2.20+_). | no | no |  |\n| `io-ports-control` | Can write to `/dev/port` to change the I/O port permissions and privilege level of the calling process and disable interrupts (_2.21+_). | no | no |  |\n| `joystick` | Can access `/dev/js*` devices (_2.24+_). | no | no |  |\n| `kernel-module-control` | Can insert kernel modules. This interface gives privileged access to the device. | no | no |  |\n| `kubernetes-support` | Can access resources and syscalls necessary to operate as the Kubernetes service and run application containers (_2.25+_). | no | no |  |\n| `kvm` | Can access `/dev/kvm` which gives privileged access to the kvm hypervisor (_2.28+_). | no | no |  |\n| `libvirt` | Can access the libvirt control socket, which gives privileged access to control libvirtd on the host. This is commonly used to create and manage QEMU/KVM instances on the host. | no | no |  |\n| `locale-control` | Can manage locales directly separate from `config core`. | no | no |  |\n| `location-control` | Can access snaps providing the location-control interface which gives privileged access to configure, observe and use location services. | no | no |  |\n| `location-observe` | Can access snaps providing the location-observe interface which gives privileged access to query location services. | no | no |  |\n| `log-observe` | Can read system logs and set kernel log rate-limiting. | no | no |  |\n| `lxd` | Can use the LXD API via the socket provided by the \"lxd\" snap. LXD_DIR must be set to /var/snap/lxd/common/lxd. This interface requires manual connection. | no | no |  |\n| `lxd-support` | Can access all resources and syscalls on the device for LXD to mediate access for its containers. This interface currently may only be established with the upstream LXD project. | no | yes |  |\n| `maliit` | Can access snaps providing the maliit input interface (_2.24+_). | no | no |  |\n| `media-hub` | Can access snaps providing the media-hub interface (_2.25+_). | yes | no |  |\n| `mir` | Can access snaps providing the mir di"
  },
  {
    "filepath": "\\reference\\interfaces\\index.md",
    "metadata": {
      "title": "Core interfaces reference",
      "table_of_contents": true
    },
    "heading": "## Interfaces (part 3)",
    "content": "splay server interface. | yes | no |  |\n| `modem-manager` | Can access snaps providing the modem-manager interface which gives privileged access to configure, observe and use modems. | no | no |  |\n| `mount-observe` | Can query system mount information. This is restricted because it gives privileged read access to mount arguments and should only be used with trusted apps. | no | no |  |\n| `netlink-audit` | Can communicate via NETLINK_AUDIT (_2.26+_). | no | no |  |\n| `netlink-connector` | Can communicate via NETLINK_CONNECTOR (_2.26+_). | no | no |  |\n| `network-control` | Can configure networking and network namespaces via `ip netns` (_2.20+_) which gives wide, privileged access to networking. | no | no |  |\n| `network-manager` | Can access snaps providing the network-manager interface which gives privileged access to configure and observe networking. | no | no |  |\n| `network-observe` | Can query network status information which gives privileged read-only access to networking information. | no | no |  |\n| `network-setup-control` | Can read/write network setup configuration files. This is restricted because it gives access to system network configuration which can container network security details (_2.22+_). | no | no |  |\n| `network-setup-observe` | Can read network setup configuration files. This is restricted because it gives access to system network configuration which can contain network security details. | no | no |  |\n| `network-status` | Can access snaps providing the NetworkingStatus interface (_2.25+_). | yes | no |  |\n| `ofono` | Can access snaps providing the ofono interface which gives privileged access to configure, observe and use ofono devices. | no | no |  |\n| `online-accounts-service` | Can access snaps providing the Online Accounts Service interface (_2.25+_). | yes | no |  |\n| `openvswitch` | Can access the openvswitch control socket, which gives privileged access to control openvswitch on the host (_2.20+_). | no | no |  |\n| `openvswitch-support` | Enables kernel support for openvswitch (_2.20+_). | no | no |  |\n| `physical-memory-control` | Can write to /dev/mem to access architecture-specific subset of the physical address space for common use cases (eg, X without KMS, dosbox, etc) when kernels are compiled with STRICT_DEVMEM=y (required for certified kernels). With STRICT_DEVMEM=n, can write to all physical memory (_2.21+_). | no | no |  |\n| `physical-memory-observe` | Can read from /dev/mem to access architecture-specific subset of the physical address space for common use cases (eg, X without KMS, dosbox, etc) when kernels are compiled with STRICT_DEVMEM=y (required for certified kernels). With STRICT_DEVMEM=n, can read from all physical memory (_2.21+_). | no | no |  |\n| `ppp` | Can access Point-to-Point protocol daemon which gives privileged access to configure and observe PPP networking. | no | no |  |\n| `process-control` | Can manage processes via signals and nice. | no | no |  |\n| `raw-usb` | Can directly access connected USB devices via a raw interface (_2.18+_). | no | no |  |\n| `serial-port` | Can access serial ports. This is restricted because it provides privileged access to configure serial port hardware. Note that the slot is meant to be implemented by a gadget snap (this is not provided by the core snap). | no | no |  |\n| `snapd-control` | Can manage snaps via snapd. | no | no |  |\n| `spi` | Can access SPI devices. This is restricted because it provides privileged access to SPI hardware (_2.28+_). | no | no |  |\n| `storage-framework-service` | Can access snaps providing the Storage Framework Service interface (_2.25+_). | no | no |  |\n| `system-observe` | Can query system status information which gives privileged read access to all processes on the system. | no | no |  |\n| `system-trace` | Can use kernel tracing facilities. This is restricted because it gives privileged access to all processes on the system and should only be used with trusted apps. | no | no |  |\n| `thumbnailer-service` | Can access snaps providing the thumbnailer service interface (_2.22+_). | no | no |  |\n| `time-control` | Can set system time and date and query systemd-timedated for time information. | no | no |  |\n| `timeserver-control` | Can manage timeservers via systemd-timedated and directly separate from `config core` | no | no |  |\n| `timezone-control` | Can manage timezone via systemd-timedated and directly separate from `config core` | no | no |  |\n| `tpm` | Can access the tpm device /dev/tpm0. | no | no |  |\n| `ubuntu-download-manager` | Can access snaps providing the ubuntu-download-manager interface. | yes | no |  |\n| `udisks2` | Can access snaps providing the udisks2 interface which gives privileged access to storage on the device | no | no |  |\n| `uhid` | Can access /dev/uhid to create kernel hid devices from user-space which gives privileged access to HID transport drivers. | no | no |  |\n| `unity8` | Can access Unity8 (_2.22+_). This interface is in active development and should n"
  },
  {
    "filepath": "\\reference\\interfaces\\index.md",
    "metadata": {
      "title": "Core interfaces reference",
      "table_of_contents": true
    },
    "heading": "## Interfaces (part 4)",
    "content": "ot yet be used in production and its use is therefore restricted. | yes | no |  |\n| `unity8-calendar` | Can access snaps providing the Unity8 calendar interface which gives access to the Unity8 global calendar. | no | no |  |\n| `unity8-contacts` | Can access snaps providing the Unity8 contacts interface which gives access to the Unity8 global contacts list. | no | no |  |\n| `upower-observe` | Can access snaps providing the UPower interface for power devices, history and statistics. | yes | no |  |"
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "# Ubuntu Core 20",
    "content": "<div class=\"p-notification--positive\"><p markdown=\"1\" class=\"p-notification__response\">\n<span class=\"p-notification__status\">UC20 is currently under active development.</span></br>\n</p></div>\n\nUbuntu Core 20 (UC20) is built on the foundations of [Ubuntu 20.04 LTS (Focal\nFossa)](https://releases.ubuntu.com/20.04/). It's the next generation of Ubuntu\nfor embedded devices.\n\nNew features for this release include:\n\n- Full-disk encryption via TPM integration </br>\n  currently x86 only with ARM to follow. beta1 TPM integration works with existing CA </br>\n- Recovery mode menu and chooser\n- A new recovery and reinstall mode\n- Initial [MAAS](https://maas.io/) & cloud-init support\n- Raspberry Pi support (both ARMv7 and ARM v8)"
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "### Latest image downloads",
    "content": "Download the latest UC20 images from:</br>\n<http://cdimage.ubuntu.com/ubuntu-core/20/candidate/pending/>"
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "## Recovery mode chooser",
    "content": "To access the recovery chooser, reset or start up UC20 while holding the `1`\nkey.\n\n![UC20 Recovery chooser](https://assets.ubuntu.com/v1/fe1a74d5-uc20_chooser_01.png)\n\n\nThe `1` key needs to be held until the initial boot process completes, after\nwhich you'll be presented first with the system selection menu followed by the\nfollowing recovery options:\n\n- **Run normally**: Continue with the boot process.\n- **Recover**: reboot into recovery mode and log into the system using prior\n  credentials to recover your data, either via SSH or locally after setting up\na password for the user.\n- **Reinstall**: initialise the device from the listed system version image.\n  All existing user data on the device will be removed."
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "## Model definition",
    "content": "The model definition has been expanded for UC20 devices to include several new\noptions, most notably grade and snaps (see [Custom\nimages](../image/custom-images) for details on building images)."
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "### `grade:`",
    "content": "Sets the constraints for the device. It can be one of the following:\n\n- **`dangerous`**: relax some of the constraints here (mandatory snap id for\n  example), and should allow for the use of unasserted snaps, devmode snaps, or\nthe presence of extra snaps in the recovery system.\n- **`signed`** _(default)_: no unasserted (unsigned) snaps or snaps not mentioned\n  in the model can appear or be used in the recovery system.\n- **`secured`**:  same properties as signed plus it is mandatory for the device to\n  use full disk encryption and secure boot."
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "### `snaps:`",
    "content": "A new header to control which snaps comprise the device setup. It consists of\nthe following keywords and mappings:\n\n- `name` _(mandatory)_: name of the snap. Cross-checked at image build time but ignored later\n- `type` _(mandatory)_: type of the snap, needs to be either: `base|gadget|kernel|app|core`.\n  _app_ is the default\n- `id` _(optional)_: id of the snap if assigned by a store. Must be omitted for local snaps.\n- `modes` _(optional)_: a list with UC20 modes (verbs, \"run\") or mode aliases (\"ephemeral\",\n  covers all recovery/tmpfs modes) for which the snap needs to be installed.\nDefault is _[run]_, should not be used for types `kernel|gadget` and for the\nsnap indicated by the \"base\" header\n- `presence` _(optional)_:  set to mark a snap whose absence will not fail\n  installation or recovery. Can be optional or required of which required  is\nthe default\n- `default-channel` _(optional)_: initial tracking channel for the snap,\n  default is \"latest/stable\"\n\nThe appearance of the snaps keyword prohibits the use of gadget, kernel and\nrequired-snaps  as the same information and more is conveyed through the snaps\nheader."
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "## Example UC20 Model definition",
    "content": "The following is an example model definition for amd64:\n\n```yaml\ntype: model\nauthority-id: canonical\nseries: 16\nbrand-id: canonical\nmodel: ubuntu-core-20-amd64-beta\narchitecture: amd64\nbase: core20\ngrade: signed\nsnaps:\n  -\n    default-channel: 20/beta\n    id: UqFziVZDHLSyO3TqSWgNBoAdHbLI4dAH\n    name: pc\n    type: gadget\n  -\n    default-channel: 20/beta\n    id: pYVQrBcKmBa0mZ4CCN7ExT6jH8rY1hza\n    name: pc-kernel\n    type: kernel\n  -\n    default-channel: latest/beta\n    id: DLqre5XGLbDqg9jPtiAhRRjDuPVa5X1q\n    name: core20\n    type: base\n  -\n    default-channel: latest/beta\n    id: PMrrV4ml8uWuEUDBT8dSGnKUYbevVhc4\n    name: snapd\n    type: snapd\ntimestamp: 2020-01-13T15:47:00.0Z\nsign-key-sha3-384:\n```"
  },
  {
    "filepath": "\\releases\\uc20.md",
    "metadata": {
      "title": "Ubuntu Core 20",
      "table_of_contents": true
    },
    "heading": "## Testing UC20",
    "content": "The easiest way to test the latest UC20 release is to download the latest image\nand either write the image to a USB storage device, and test the build on real\nhardware, or use the image with a virtual machine.\n\nIf your hardware supports TPM, and has [UEFI Secure\nBoot](https://wiki.ubuntu.com/UEFI/SecureBoot) enabled, UC20 will use these to\ndeploy a fully encrypted system. When redeploying to the same device, the TPM\nwill need to be cleared.\n\nTo test UC20 with QEMU ([https://www.qemu.org/](https://www.qemu.org)), first install the\n[OVMF](https://wiki.ubuntu.com/UEFI/OVMF) package (eg. `sudo apt install ovmf`)\nthen run the following command to boot a UC20 image (renamed pc.img) within a\nvirtual machine:\n\n```bash\nsudo qemu-system-x86_64 -smp 2 -m 2048 \\\n -net nic,model=virtio -net user,hostfwd=tcp::8022-:22 \\\n -drive file=/usr/share/OVMF/OVMF_CODE.fd,if=pflash,format=raw,unit=0,readonly=on \\\n -drive file=pc.img,cache=none,format=raw,id=disk1,if=none \\\n -device virtio-blk-pci,drive=disk1,bootindex=1 -machine accel=kvm\n```\n\n<div class=\"p-notification--warning\"><p markdown=\"1\" class=\"p-notification__response\">\n<span class=\"p-notification__status\">Older OVMF packages can cause QEMU boot problems. Either <a href=\"https://github.com/tianocore/tianocore.github.io/wiki/How-to-run-OVMF\">build them manually</a>, or consider extracting the files from a more recent package. <a href=\"https://packages.ubuntu.com/focal/powerpc/ovmf\">OVMF</a> for <a href=\"https://releases.ubuntu.com/20.04/\">Ubuntu 20.04 LTS (Focal Fossa)</a> is known to work.\n</p></div>\n\nWith a successful boot, Ubuntu Core initialisation will ask for both networking\nparameters and an Ubuntu One account (see <https://snapcraft.io/account>). \n\nWhen the initialisation process has finished, and rebooted, you can SSH to the\ndevice using either the physical device network address,  or localhost port\n8022 for the above QEMU example command:\n\n```bash\n$ ssh <username>@localhost -p 8022\n```"
  },
  {
    "filepath": "\\stacks\\audio\\index.md",
    "metadata": {
      "title": "Audio management"
    },
    "heading": "# Audio management",
    "content": "There are currently two different snaps that help manage audio under Ubuntu Core Stacks:\n\n* [alsa-utils](alsa-utils/docs/index.md)\n* [pulseaudio](pulseaudio/docs/index.md)"
  },
  {
    "filepath": "\\stacks\\bluetooth\\index.md",
    "metadata": {
      "title": "Bluetooth Management"
    },
    "heading": "# Bluetooth Management",
    "content": "The following snap is used to manage Bluetooth devices under Ubuntu Core Stacks\n\n* [bluez](bluez/docs/index.md)"
  },
  {
    "filepath": "\\stacks\\disk\\index.md",
    "metadata": {
      "title": "Disk management"
    },
    "heading": "# Disk management",
    "content": "The [udisks2](https://code.launchpad.net/~snappy-hwe-team/snappy-hwe-snaps/+git/udisks2)\nsnap that was used to manage disks has been deprecated and is no longer supported.\n\nFor further details, see [udisks2 snap\nremoved](https://forum.snapcraft.io/t/udisks2-snap-removed-alternatives/12467/2)\non [forum.snapcraft.io](https://forum.snapcraft.io/)."
  },
  {
    "filepath": "\\stacks\\location\\index.md",
    "metadata": {
      "title": "Location Services"
    },
    "heading": "# Location Services",
    "content": "The following snap is used to manage location services under Ubuntu Core Stacks\n\n* [locationd](location-service/docs/index.md)"
  },
  {
    "filepath": "\\stacks\\network\\index.md",
    "metadata": {
      "title": "Network management & services"
    },
    "heading": "# Network management & services",
    "content": "There are currently several snaps which manage networking, modems, OpenVPN,\nand one that instantly creates a wireless access point:\n\n* [modem-manager](modem-manager/docs/index.md)\n* [network-manager](network-manager/docs/index.md)\n* [wpa-supplicant](wpa-supplicant/docs/index.md)\n* [easy-openvpn](easy-openvpn/docs/index.md)\n* [wifi-ap](wifi-ap/docs/index.html)"
  },
  {
    "filepath": "\\stacks\\power\\index.md",
    "metadata": {
      "title": "Power Management"
    },
    "heading": "# Power management",
    "content": "The following snap is used to help manage power consumption under Ubuntu Core Stacks:\n\n* [upower](upower/docs/index.md)"
  },
  {
    "filepath": "\\stacks\\utilities\\index.md",
    "metadata": {
      "title": "Utilities"
    },
    "heading": "# Utilities",
    "content": "The following utility is useful for multiple git repository relationship\nmanagement.\n\n* [git-repo](developer/git-repo/docs/index.md)"
  }
]